# TCP/IP 4계층 모델

### TCP/IP란 ?

---

인터넷에서 컴퓨터들이 서로 정보를 주고받는 데 쓰이는 `프로토콜`의 집합.
<img width="802" alt="Untitled" src="https://github.com/STUDY-0x0E/CS-STUDY/assets/72375302/89ef843a-99af-423b-932d-40bc0c8f5353">

가장 왼쪽부터 `osi 7 layer`, 그리고 간소화된 `tcp/ip 4계층` 그리고 업데이트된 `tcp/ip 5계층`입니다.

이 책에서는 4계층으로 설명하고 있습니다.

### 네 번째 계층. Application layer ( 애플리케이션 계층 )

---

FTP, HTTP, SSH, SMTP, DNS등 응용 프로그램이 사용하는 프로토콜이 존재하는 계층이며, 웹 서비스, 이메일 등 **서비스를 실질적으로 사람들에게 제공**하는 층입니다.

- FTP, HTTP, SSH, SMTP, DNS란?
    1. **FTP (File Transfer Protocol):** `파일 전송`을 위한 프로토콜로, 파일을 서버와 클라이언트 간에 전송하고 관리하는 데 사용됩니다.
    2. **HTTP (HyperText Transfer Protocol):** `웹 페이지를 전송`하는 데 사용되는 프로토콜입니다. 주로 웹 브라우저와 웹 서버 간의 통신에 사용됩니다.
    3. **SSH (Secure Shell):** 원격 제어 및 안전한 데이터 통신을 위한 프로토콜입니다. 주로 `리모트 서버에 접속하거나 파일을 안전하게 전송`하는 데 사용됩니다.
    4. **SMTP (Simple Mail Transfer Protocol):** `이메일을 전송`하는 데 사용되는 프로토콜입니다. 이메일 클라이언트가 이메일 서버로부터 이메일을 받거나, 이메일 서버가 이메일을 다른 서버로 전송할 때 사용됩니다.
    5. **DNS (Domain Name System):** `도메인 이름을 IP 주소로 변환`하거나, 그 반대로 IP 주소를 도메인 이름으로 변환하는 데 사용되는 프로토콜입니다.

### 세 번째 계층. Transport layer ( 전송 계층 )

---

송신자와 수신자를 연결하는 `통신 서비스를 제공`합니다. TCP/IP 에서는 TCP 뿐만 아니라 인터넷을 위한 프로토콜을 모두 내포하고 있습니다. 예를들면 TCP, UDP, IPv4, IPv6, DHCP, HTTP 등등이 있는데, 대표적으로 `TCP` 와 `UDP`가 있습니다.

| 특성 | TCP | UDP |
| --- | --- | --- |
| 연결 지향 | Yes | No |
| 신뢰성 | 높음 (전송 과정에서 데이터 손실 및 순서 뒤바뀜 방지) | 낮음 (데이터 손실이나 순서 뒤바뀜 가능) |
| 전송 속도 | 상대적으로 느림 (연결 설정 및 신뢰성 유지 추가 작업 때문) | 빠름 (연결 설정 단계가 없어 빠르게 전송 가능) |
| 흐름 제어 및 혼잡 제어 | Yes | No |
| 헤더 크기 | 상대적으로 큼 (TCP 헤더 크기가 큼) | 작음 (UDP 헤더 크기가 작음) |
| 사용 예시 | 웹 브라우징, 이메일 전송, 파일 전송 등 | 음성/영상 스트리밍, 게임, DNS 등 |
| 예시 프로토콜 | HTTP, FTP, SMTP, Telnet 등 | DNS, DHCP, VoIP (보이스 오버 IP), 게임 프로토콜 등 |
| 패킷 교환 방식 | 가상 회선 패킷 교환 방식 | 데이터그램 패킷 교환 방식 |

- 가상 회선 패킷 교환 방식 ( TCP )
<img width="371" alt="Untitled 1" src="https://github.com/STUDY-0x0E/CS-STUDY/assets/72375302/a7183e57-effb-405d-bce4-1112af9fac9a">

패킷이 `설정된 경로를 통해서` 이동하기때문에, 도착 순서가 달라지지 않습니다.

- 데이터그램 패킷 교환 방식 ( UDP )

<img width="384" alt="Untitled 2" src="https://github.com/STUDY-0x0E/CS-STUDY/assets/72375302/4e40d94c-317e-41da-a919-c9975b911b92">


각 패킷이 `독립적으로 최적의 경로를 선택`하여 이동하기때문에, 도착 순서가 달라질 수 있습니다.

- TCP의 연결 ( 3-way handshake )
    
    `신뢰성`을 확보하기 위한 작업
    
    3way handshake는 양쪽 모두 데이터를 `전송할 준비`가 되어있다는 것을 보장하고, 실제로 데이터 전달이 시작하기 전에 다른 한쪽이 준비되었다는 것을 알 수 있도록 해준다

<img width="748" alt="Untitled 3" src="https://github.com/STUDY-0x0E/CS-STUDY/assets/72375302/9d8f8e47-f97a-40e5-837c-968e9470c0df">

    
    1. `SYN 단계`: 클라이언트에서 클라이언트의 ISN( 새로운 TCP 연결의 첫 번째 패킷에 할당된 임의의 시퀀스 번호 ) 을 담아서 서버로 SYN을 보냅니다. 
    2. `SYN + ACK 단계`: 클라이언트로부터 SYN를 수신하고, 서버의 ISN을 보내고, 승인번호로 클라이언트의 ISN + 1을 보냅니다.
    3. `ACK 단계`: 서버의 ISN + 1한 값인 승인번호를 담아서 ACK를 서버에 보냅니다.
    
- TCP 연결 해제 ( 4-way handshake )
    
    3-Way handshake는 TCP의 연결을 초기화 할 때 사용한다면,
    
    4-Way handshake는 `세션을 종료`하기 위해 수행되는 절차입니다.


<img width="548" alt="Untitled 4" src="https://github.com/STUDY-0x0E/CS-STUDY/assets/72375302/fa5b95d7-a8d3-4971-8370-35b4734e4ab3">

    
    1. A 클라이언트에서 서버로 `FIN으로 설정된 세그먼트`를 보냅니다. 이때 **A클라이언트는  FIN-WAIT** 상태가 된다.
    2.  B 서버는 FIN플래그를 받고, 일단 `확인메시지 ACK` 보내고 자신의 통신이 끝날때까지 기다리는데 이때 B 서버의 상태는 **CLOSE_WAIT**상태다.
    3. 연결을 종료할 준비가 되면, 연결해지를 위한 준비가 되었음을 알리기 위해  클라이언트에게 `FIN플래그`를 전송한다. 이때 B 서버의 상태는 **LAST-ACK**이다.
    4. 클라이언트는 `해지준비가 되었다는 ACK`를 확인했다는 메시지를 보낸다. 이 때 A 클라이언트의 상태는 **FIN-WAIT ->TIME-WAIT** 으로 변경된다.
    5. TIME-WAIT상태로 대기하다가 일정 시간이 흐른 후 연결을 닫습니다. 
        
        ( 지연 패킷일 발생할 경우를 대비하기 위해서 - 데이터 무결성 문제 발생 예방 )
        
        ( 두 장치가 연결이 닫혔는지 확인하기 위해서 )
        
    
    | 행동 | 주체 | 상태 변경 |
    | --- | --- | --- |
    | A 클라이언트에서 FIN으로 설정된 세그먼트 전송 | A 클라이언트 | A 클라이언트: FIN-WAIT |
    | B 서버가 FIN을 받고, ACK로 확인 메시지 전송 | B 서버 | B 서버: CLOSE_WAIT |
    | B 서버가 연결을 종료하기 위해 FIN 플래그 전송 | B 서버 | B 서버: LAST-ACK |
    | A 클라이언트가 FIN을 받고, ACK로 확인 메시지 전송 | A 클라이언트 | A 클라이언트: FIN-WAIT -> TIME-WAIT |

### 두 번째 계층. Internet layer ( 인터넷 계층 )

---

1. **역할**
    - 네트워크 계층은 `패킷을 목적지로 전달하는 역할`을 합니다. 이를 위해 최적의 경로를 선택하고 중간에 있는 라우터들을 거쳐 목적지까지 전송합니다.
2. **프로토콜**
    - 주로 IP 프로토콜이 이 계층에서 사용됩니다. `IP 주소를 사용`하여 목적지를 지정하고, 패킷을 전달합니다.
    - ARP(Address Resolution Protocol)은 `IP 주소를 물리적인 MAC 주소로 변환`합니다.
    - ICMP(Internet Control Message Protocol) 은 `네트워크 상태 및 오류 메시지를 전송`합니다.
3. **비 연결형 특징**
    - 네트워크 계층은 연결 설정 없이 패킷을 전송합니다. 이는 상대방이 패킷을 정상적으로 받았는지를 확인하지 않습니다. 따라서 `패킷 손실이나 순서 변경이 발생할 수 있습니다`.
4. **라우팅**
    - 네트워크 계층에서는 패킷의 `최적 경로를 선택하는 라우팅`이 이루어집니다. 이를 통해 목적지로 가는 최적의 경로를 선택하여 효율적으로 패킷을 전달합니다.
5. **예시**
    - 인터넷에서 데이터를 주고받을 때, 패킷은 송신자에서 출발하여 네트워크 계층에서는 IP 주소를 확인하여 어느 라우터로 보낼지 결정하고, 라우터를 거쳐 목적지에 도달하게 됩니다.

### 첫 번째 계층. Link layer ( 링크 계층 )

---

전선, 광섬유, 무선 등을 실질적으로 데이터를 전달하며 장치간에 신호를 주고받는 규칙을 정하는 계층입니다.

tcp/ip updated 버전에서는 이 계층이 물리계층과, 데이터링크 계층으로 나뉩니다.

- 전이중화 통신
    
    유선 LAN을 이루는 이더넷에서 사용하는 통신 방법으로, 양쪽 장치가 `동시에 송수신` 할 수 있는 방식을 말합니다. `송신로와 수신로를 나눠서` 데이터를 주고받으며, 현대의 이더넷이 이 방식을 기반으로 통신하고 있습니다.
    
- CSMA/CD
    
    전이중화 통신 이전에 사용하던 방식. 
    
    데이터를 보낸 이후, `충돌이 발생한다면 일정 시간 이후 재전송`하는 방식을 말합니다.
    
    수신로와 송신로를 따로 두는 전이중화 통신과 다르게 `하나의 경로를 기반으로` 데이터를 보내기 때문에 데이터를 보낼 때 `충돌에 대해 대비`하는 통신 방식입니다.
    
- LAN
    1. 유선 LAN  케이블
        
        TP케이블이라고 하는 `트위스트 페어 케이블`과, `광섬유 케이블`이 대표적입니다.
        
        1) 트위스트 페어 케이블
        
        하나의 케이블처럼 보이지만, 실제로는 여덟 개의 구리선을 두 개씩 꼬아서 묶은 케이블입니다.
        
        - **UTP (Unshielded Twisted Pair)**:
            - UTP는 외부 간섭으로부터 보호되지 않은 트위스트 페어 케이블입니다.
            - 여기서 "트위스트 페어"는 두 개의 동일한 길이의 전선이 함께 묶여 있고, 이들이 서로 뒤섞여 있는 구조를 말합니다.
            - UTP는 주로 이더넷 네트워크에 사용되며, 일반적으로 사무실이나 가정에서 많이 볼 수 있는 네트워크 케이블입니다.
            - UTP는 비교적 저렴하고 유연하며 설치가 쉽습니다.
        - **STP (Shielded Twisted Pair)**:
            - STP는 외부 간섭으로부터 보호되기 위해 전기적으로 차폐된 트위스트 페어 케이블입니다.
            - 각 페어마다 별도의 도금된 화살표로 된 덮개(실드)가 있어서 외부 간섭을 흡수하고 차단합니다.
            - STP는 더 높은 노이즈 환경에서 사용하거나 전자기 간섭이 많은 환경에서 사용됩니다.
            - 그러나 UTP보다 비용이 더 들고, 설치 및 유지보수가 복잡할 수 있습니다.
        
        2) 광섬유 케이블
        
        광섬유로 만들어진 케이블이고, 레이터로 통신하기 때문에 구리선과는 비교할 수 없을 만큼의 `장거리 및 고속 통신`이 가능합니다.
        
    
    1. 무선 LAN
        
        `수신과 송신에 같은 채널을 사용`하기 때문에 반이중화 통신을 사용합니다.
        
        블루투스, 와이파이 등등이 있습니다.
        
- 반이중화 통신
    
    양쪽 장치가 `서로 통신할 수 있지만, 동시에는 통신할 수 없으며`, 한 번에 한 방향만 통신할 수 있는 방식을 말합니다. 둘 이상의 장치가 동시에 전송시, 충돌이 발생하여 메시지가 손실되거나, 왜곡될 수 있기때문에 `충돌 방지 시스템 CSMA/CA 가 필요`합니다.
    
- CSMA/CA
    
    반이중화 통신 중 하나로, 데이터를 보내기 전에 캐리어 감지 등으로 `사전에 가능한 한 충돌을 방지하는 방식`을 사용합니다.
    
    1. **무선 매체 살피기**:
        - 데이터를 송신하기 전에, 무선 매체(또는 회선)를 관찰합니다.
    2. **캐리어 감지**:
        - 무선 매체가 `사용 중인지를 판단`합니다. 다른 장치가 데이터를 전송 중인 경우, 충돌이 발생할 수 있으므로 기다려야 합니다.
    3. **IFS(Inter Frame Space)**:
        - 데이터를 송신하기 전에 `랜덤한 시간 동안 기다리는데`, 이를 IFS라고 합니다. 만약 무선 매체가 계속해서 사용 중이면, 기다리는 간격을 늘려가며 충돌을 방지합니다.
    4. **데이터 송신**:
        - IFS 이후에 충돌이 발생하지 않았다면, 데이터를 송신합니다.
    
- BSS와 ESS
    1. **BSS (Basic Service Set):**
        
        BSS는 무선 네트워크에서 기본적인 서비스 단위를 나타냅니다. 하나의 BSS는 `하나의 무선 액세스 포인트` (Wireless Access Point, AP)와 이를 통해 연결된 클라이언트 장치들로 구성됩니다.
        
        BSS는 물리적인 영역을 나타내며, 일반적으로 AP의 무선 신호 범위 내에 있는 장치들을 포함합니다. 이러한 장치들은 AP를 통해 네트워크에 연결되어 통신합니다. BSS는 어떤 네트워크 구성에서 가장 기본적인 단위이며, 하나의 BSS 내에서는 동일한 네트워크 이름(SSID)을 사용합니다.
        
    2. **ESS (Extended Service Set):**
        
        ESS는 여러 개의 BSS들을 하나로 연결하여 더 큰 무선 네트워크를 형성하는 것을 나타냅니다. ESS는 여러 개의 AP들을 사용하여 네트워크의 범위를 확장하고, 클라이언트 장치들이 AP 간에 로밍하여 연결 상태를 유지할 수 있게 합니다.
        
        ESS를 통해 더 큰 영역을 커버하고, 클라이언트 장치들은 필요에 따라 자유롭게 AP 간에 이동하며 연결을 유지할 수 있습니다. 이는 예를 들어 공항, 학교, 또는 대규모 건물에서 무선 네트워크를 구성할 때 유용합니다.
        
    
    - 캡슐화
        
        **캡슐화**
        
        데이터가 송신자에서 수신자로 전송될 때, 각 계층은 특정한 기능을 수행하고 데이터에 헤더와 트레일러를 추가합니다. 이를 캡슐화라고 합니다.
        
        1. **애플리케이션 계층**
            - 데이터에 애플리케이션 계층의 데이터를 추가합니다. 예를 들어, 웹 브라우저가 HTTP 요청 메시지를 만들어 데이터에 추가합니다.
        2. **전송 계층**
            - 애플리케이션 계층에서 받은 데이터에 전송 계층의 헤더를 추가합니다. 이 헤더에는 포트 번호, 순서 번호 등의 정보가 들어있습니다.
        3. **인터넷 계층**
            - 전송 계층에서 받은 데이터에 인터넷 계층의 헤더를 추가합니다. 이 헤더에는 출발지 및 목적지 IP 주소 등의 정보가 들어있습니다.
        4. **네트워크 접근 계층**
            - 인터넷 계층에서 받은 데이터에 네트워크 접근 계층의 헤더와 트레일러를 추가합니다. 이 헤더에는 MAC 주소 등의 정보가 들어있습니다.
        
        결과적으로, 데이터는 각 계층을 거치면서 계층별로 헤더 정보가 추가되어 하나의 패킷이 형성됩니다.
        
        **비캡슐화**
        
        수신자 측에서는 반대로 작동합니다. 패킷이 수신되면, 각 계층에서 해당하는 헤더 정보가 읽히고, 해당 계층의 기능에 따라 처리됩니다. 최종적으로 애플리케이션 계층으로 데이터가 전달되고, 최종적으로 애플리케이션의 PDU인 메시지로 전달됩니다.
