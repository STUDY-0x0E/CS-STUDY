# 5. CPU 스케줄링

## 5.1 CPU 스케줄링의 개념

### 5.1.1 CPU 스케줄링이란?

하나의 CPU는 한순간에 하나의 프로세스만을 실행할 수 있다. 

CPU가 어떤 한 프로세스의 실행을 마친 후 어떤 프로세스를 선택할 것인지 **프로세스의 실행 순서를 정하는 것**을 CPU 스케줄링이라고 한다.

### 5.1.2 CPU-I/O Burst Cycle

프로세스들은 교대로 CPU가 프로세스를 **실행하는 상태**와 **입/출력을 위한 상태**가 된다.

<p align="center"><img width="30%" src="https://github.com/parkyolo/study-cs/assets/39394642/698b4bf6-048f-4c25-80f8-099df48da3f8"></p>

- **CPU Burst 상태**: CPU 연산을 수행하는 상태
- **I/O burst 상태**: 입출력이 필요한 상태

I/O burst 상태에서 CPU는 대기하게 된다. 이는 굉장한 낭비이기 때문에 I/O burst 상태에서 다른 프로세스를 수행한다면 CPU의 효율은 더 커질 것이다.

<p align="center"><img width="60%" src="https://github.com/parkyolo/study-cs/assets/39394642/52ac5038-3dbf-4744-a519-115760ac69fb"></p>

CPU burst의 지속 시간을 광범위하게 측정해보면 위 그림과 유사한 빈도수 곡선을 갖는 경향이 있다. 이 곡선은 일반적으로 지수형 또는 초지수형(htperexponential)으로 특성화된다. **짧은 CPU 버스트가 많이 있으며, 긴 CPU 버스트는 적다.**

일반적으로 **입/출력 중심의 프로그램**은 **짧은 CPU burst**를 가지고, 반대로 **CPU 지향 프로그램**은 **긴 CPU burst**를 가진다. 이러한 분포는 CPU 스케줄링 알고리즘을 구현할 때 매우 중요할 수 있다.

### 5.1.3 CPU 스케줄러란?

CPU가 유휴 상태(사용 가능한 상태)가 될 때마다, **CPU 스케줄러**에 의해 운영체제는 **Ready 큐에 있는 프로세스들 중 하나를 선택해 CPU에 할당**한다.

<details>
  <summary>Ready 큐</summary>
  Ready 큐는 선입선출 큐(FIFO Queue), 우선순위 큐(Priority Queue), 트리(Tree) 또는 연결 리스트(Linked List)로 구현할 수 있다. 큐에 있는 레코드들은 일반적으로 프로세스들의 프로세스 제어 블록(PCB)들이다.  
</details>

### 5.1.4 선점 스케줄링<sup>**Preemptive Scheduling**</sup>과 비선점 스케줄링<sup>**Non-Preemptive Scheduling**</sup>

**선점 스케줄링**은 한 프로세스가 **실행 중일때 스케줄러에 의해** 현재 프로세스의 **CPU 제어권을 다른 프로세스한테 넘기는 스케줄링**을 의미한다. 실행 중인 프로세스가 다른 프로세스에게 CPU 제어권을 선점당하면 **Running 상태에서 Ready 상태**로 변하고, 입/출력 대기 중인 프로세스가 다른 프로세스에게 CPU를 선점당하면 **입/출력 대기 상태에서 Ready 상태**로 전환된다.

**비선점 스케줄링**은 CPU가 현재 실행 중인 프로세스가 **완료될 때까지** 다른 프로세스들은 **대기하는 스케줄링**을 의미한다. 오직 현재 실행중인 프로세스가 **종료**되거나 입/출력을 위하여 **대기 상태**로 전환되는 경우에만 다른 프로세스들이 실행될 수 있다.

다음과 같은 상황에서 CPU 스케줄링이 필요하다.

1. 한 프로세스가 실행 상태에서 대기 상태로 전환 될 때(입/출력 요청 등)
2. 프로세스가 실행 상태에서 준비 완료 상태로 전환 될 때(다른 프로세스의 인터럽트 발생 등)
3. 프로세스가 대기 상태에서 준비 완료 상태로 전환 될 때(입/출력의 종료 등)
4. 프로세스가 종료될 때

### 5.1.5 Dispatcher

디스패처<sup>dispatcher</sup>는 CPU의 제어를 단기 스케줄러가 선택한 프로세스에게 주는 모듈이다. 스케줄러가 교체할 프로세스를 선택하면 디스패처가 **실제로 교체하는 역할**을 하는 것이다. 디스패처는 다음과 같은 작업을 한다.

- 문맥 교환<sup>context switching</sup>
- 사용자 모드<sup>user mode</sup>로 전환
- 프로그램을 다시 시작하기 위해 사용자 프로그램의 적절한 위치로 이동

디스패처는 모든 프로세스의 문맥 교환 시 호출되므로, 가능한 빨리 수행되어야 한다.

**디스패치 지연**<sup>dispatch latency</sup>이란 디스패처가 하나의 프로세스를 정지하고 다른 프로세스의 수행을 시작하는 데까지 소요되는 시간을 의미한다.

### 5.1.6 스케줄링 기준

CPU 스케줄링 알고리즘을 선택하려면, 다양한 알고리즘들의 서로 다른 특성을 반드시 고려해야 한다. CPU 스케줄링 알고리즘을 비교하기 위한 기준은 다음과 같다.

- CPU 이용률(CPU Utilization): CPU 이용률은 0에서 100%까지 이른다. 실제 시스템에서는 40%~90%까지의 범위를 가져야 한다.
- 처리량(Throughput): 단위 시간당 완료된 프로세스의 개수
- 총 처리 시간(Turnaround Time): 총처리 시간은 프로세스의 제출 시간과 완료 시간의 간격이다. 즉, 메모리에 들어가기 위해 기다리며 소비한 시간과 준비 완료 큐에서 대기한 시간, CPU에서 실행하는 시간, 입/출력 시간을 합한 시간이다.
- 대기 시간(Wating Time): 프로세스가 Ready 큐에서 대기한 시간의 합
- 응답 시간(Response Time): 하나의 요청을 제출한 후 첫 번째 응답이 나올 때까지의 시간

**CPU 이용률과 처리량을 최대화**하고 **총처리 시간, 대기시간, 응답시간을 최소화**하는 것이 바람직하다.

## 5.2 스케줄링 알고리즘

CPU 스케줄링 알고리즘은 다음과 같은 종류가 있다.

- 선입 선처리 스케줄링(First-Come, First-Served Scheduling)
- 최단 작업 우선 스케줄링(Shortest-Job-First Scheduling)
- 우선순위 스케줄링(Priority Scheduling)
- 라운드 로빈 스케줄링(Round-Robin Scheduling)
- 다단계 큐 스케줄링(Multi-Level Queue Scheduling)
- 다단계 피드백 큐 스케줄링(Multi-Level Feedback Queue Scheduling)

### 5.2.1 FCFS(First-Come, First-Served) 스케줄링

FCFS 스케줄링은 가장 단순한 스케줄링 알고리즘이다. **CPU를 먼저 요청하는 프로세스가 먼저 CPU를 할당**받는다. FIFO 큐 자료구조로 쉽게 관리할 수 있다. FCFS 알고리즘은 비선점형 알고리즘이다.

FCFS 스케줄링의 문제점은 평균 대기 시간이 매우 길 수 있다는 것이다.

<p align="center"><img width="60%" src="https://github.com/parkyolo/study-cs/assets/39394642/bac5a92c-d381-49c2-93ed-f5d4b8526316"></p>

아래 그림은 만약 수행시간이 짧은 순서로 도착하였을 때의 대기시간을 계산한 것이다.

<p align="center"><img width="60%" src="https://github.com/parkyolo/study-cs/assets/39394642/dfc845b5-2ef5-43bc-b64e-8d9f0037f9a3"></p>

수행 시간이 짧은 순서로 온 프로세스를 먼저 처리하면 평균 대기시간이 매우 단축된 것을 볼 수 있다.

아래 그림은 FCFS 스케줄링 정책에서 총 처리시간을 계산한 것이다.

<p align="center"><img width="60%" src="https://github.com/parkyolo/study-cs/assets/39394642/92423b53-ce14-43cb-aa12-69116793ca47"></p>

수행시간이 긴 프로세스가 먼저 수행되면 다른 프로세스들의 대기 시간이 길어지고 총 처리 시간도 길어진 것을 볼 수 있다.

<p align="center"><img width="60%" src="https://github.com/parkyolo/study-cs/assets/39394642/69109e56-7211-49af-a772-00ae0d9b3898"></p>

위 그림과 같이 프로세스의 수행시간이 짧은 순서로 왔다고 가정하면 대기 시간이 줄어들어 총 처리 시간도 줄어든 것을 볼 수 있다.

위 예제를 통해 **FCFS 알고리즘의 평균 대기시간**은 **프로세스의 도착 순서**에 많은 영향을 받는다는 것을 알 수 있다.

특히 문제가 되는 상황은 하나의 CPU-bound 프로세스(CPU 소모가 큰 프로세스)가 많은 IO-bound 프로세스(I/O 처리가 많은 프로세스) 앞에 배치되는 상황이다. 
이 경우 모든 I/O-bound 프로세스가 CPU-bound 프로세스의 종료를 기다려야 하는 <strong>호송 효과</strong><sup>Convoy Effect</sup>가 발생하게 된다.

### 5.2.2 SJF(Shortest-Job-First Scheduling) 스케줄링

SJF 스케줄링은 **가장 작은 프로세스를 우선적으로 할당**한다. 두 프로세스가 **동일한 길이**의 CPU burst를 가지면, **FCFS 스케줄링**을 적용한다. 

SJF 알고리즘은 대기 시간 측면에서 최적인 방식이지만, 실제로는 다음 CPU의 burst time을 알 수 없다는 어려움이 있다. 때문에 과거의 CPU 사용량에 기반하여 **근사적으로 다음 CPU burst time을 예측**한다.

**선점형 SJF 스케줄링과 비선점형 SJF 스케줄링**

SJF 스케줄링은 선점형 또는 비선점형일 수 있다. 앞의 프로세스가 실행되는 동안 새로운 프로세스가 Ready 큐에 도착하면 선택이 발생한다. 새로운 프로세스가 현재 실행 되고 있는 프로세스의 남은 시간보다도 더 짧은 CPU burst를 가질 경우 선점형 스케줄링은 새로운 프로세스가 CPU를 선점할 것이고, 반면에 비선점형 스케줄링은 현재 실행하고 있는 프로세스가 자신의 CPU burst를 끝내도록 허용할 것이다. 선점형 SJF 스케줄링은 **최소 잔여 시간 우선<sup>shortest remaining time first</sup> 스케줄링**이라고 불리기도 한다.

### 5.2.3 우선순위(Priority) 스케줄링

Priority 스케줄링은 **가장 높은 우선순위**를 가진 프로세스에게 CPU를 할당하는 방식이다. **우선순위가 같은** 프로세스가 있다면 **FCFS 스케줄링**을 적용한다. SJF 알고리즘은 CPU burst time이 짧을수록 높은 우선순위를 가지는 알고리즘이다.

일반적으로 우선순위는 0&#126;7 또는 0&#126;4095까지 일정 범위의 수를 사용하고 0이 최상위 우선순위이다.

다음 그림은 프로세스 5개를 Priority 스케줄링 방식으로 평균 대기시간과 평균 총처리 시간을 계산한 결과이다.

<p align="center"><img width="70%" src="https://github.com/parkyolo/study-cs/assets/39394642/0d214b22-aea0-46e2-a48c-8f25fab59125"></p>

우선순위는 내부적 또는 외부적으로 정의될 수 있다.

**내부적 우선순위**는 프로세스의 우선순위를 결정하기 위해 **측정 가능한 양**을 사용한다.

- 시간 제한
- 메모리 요구
- 열린 파일의 수
- 평균 I/O burst의 평균 CPU burst에 대한 비율 등

**외부적 우선순위**는 운영체제 외부적인 기준에 의해 결정된다.

- 프로세스의 중요성
- 컴퓨터 사용을 위해 지불되는 비용
- 정치적 요인 등

**선점형 우선순위 스케줄링과 비선점형 우선순위 스케줄링**

우선순위 스케줄링은 선점형 또는 비선점형일 수 있다. 앞의 프로세스가 실행되는 동안 새로운 프로세스가 Ready 큐에 도착하면, 새로운 프로세스의 우선순위를 현재 실행 중인 프로세스의 우선순위와 비교한다. 새로운 프로세스의 우선순위가 현재 실행되는 프로세스의 우선순위보다 높을 경우 선점형 스케줄링은 새로운 프로세스가 CPU를 선점하고, 비선점형 스케줄링은 Ready 큐의 앞에 새로운 프로세스를 추가한다.

**우선순위 스케줄링 알고리즘의 문제점**

우선순위 스케줄링 알고리즘의 주요 문제는 **무한 봉쇄**<sup>indefinite blocking</sup> 또는 **기아 상태**<sup>starvation</sup>이다. **우선순위가 낮은 프로세스들이 CPU를 무한히 대기**하는 경우가 발생한다.

이를 해결하는 한 가지 방안은 **노화**<sup>aging</sup>인데, 이는 오랫동안 시스템에서 대기하는 프로세스들의 우선순위를 점진적으로 증가시키는 기법이다.

### 5.2.4 RR(Round-Robin) 스케줄링

라운드 로빈 스케줄링은 FCFS 스케줄링과 유사하지만 **선점이 추가**된 방식이다. **시간 할당량(time quantum)** 또는 <strong>시간 조각(time slice)</strong>이라고 하는 작은 단위의 시간을 정의한다. 시간 할당량은 일반적으로 10에서 100밀리초이다.

Ready 큐는 원형 큐(circular queue)로 동작하며, CPU 스케줄러는 Ready 큐를 돌면서 **한 번의 시간 할당량동안 한 프로세스에게 CPU를 할당**한다.

- 프로세스의 CPU burst가 시간 할당량보다 짧은 경우
1. 프로세스 자신이 CPU를 자발적으로 방출
2. 스케줄러는 Ready 큐의 다음 프로세스 선택
- 프로세스의 CPU burst가 시간 할당량보다 긴 경우
1. 타이머가 끝나면 운영체제에게 인터럽트를 발생시킴
2. 문맥 교환 수행
3. 실행하던 프로세스를 Ready 큐의 꼬리에 넣음
4. 스케줄러는 Ready 큐의 다음 프로세스 선택

<p align="center"><img width="70%" src="https://github.com/parkyolo/study-cs/assets/39394642/e4e46e82-e54a-4849-a8fa-adc787c46fc7"></p>

라운드 로빈 스케줄링의 성능은 **시간 할당량의 크기에 매우 많은 영향**을 받는데, 시간 할당량이 너무 짧아서 문맥 교환 시간이 더 길어지면 프로세스가 수행이 되지 않을 것이고, 시간 할당량이 너무 길어지면 FCFS 스케줄링 방식으로 작동하게 된다.

### 5.2.5 **Multi-Level Queue 스케줄링**

다단계 큐 스케줄링은 **Ready 큐를 다수의 별도의 큐로 분류**하여 수행하는 방식이다. 프로세스들은 메모리 크기, 프로세스의 우선순위 등의 특성에 따라 다수의 큐 중 한 개의 큐에 영구적으로 할당된다. 각각의 큐는 자신만의 스케줄링 알고리즘을 갖는다.

<p align="center"><img width="80%" src="https://github.com/parkyolo/study-cs/assets/39394642/06e94aaa-67c4-4668-82bc-1a38b4ad71b6"></p>

위의 그림에서 각 큐는 낮은 우선순위 큐보다 **절대적인 우선순위**를 가진다. 예를 들어 실시간 프로세스, 시스템 프로세스를 위한 큐들이 모두 비어 있지 않으면, 대화형 프로세스 큐에 있는 프로세스는 실행될 수 없다. 그리고 대화형 프로세스 큐에 있는 프로세스가 실행 중일 때 높은 우선순위의 큐에 프로세스가 들어오면 선점된다.

### 5.2.6 **Multi-Level Feedback Queue 스케줄링**

**다단계 큐 스케줄링 알고리즘**에서는 일반적으로 프로세스들이 시스템 진입 시에 영구적으로 하나의 큐에 할당되어 **다른 큐로 이동하지 못한다.** 이러한 방식은 **적은 스케줄링 오버헤드**가 장점이지만 **융통성이 적다**는 단점이 존재합니다.

**다단계 피드백 큐 스케줄링 알고리즘**에서는 **프로세스가 큐들 사이로 이동하는 것을 허용**한다.

<p align="center"><img width="50%" src="https://github.com/parkyolo/study-cs/assets/39394642/54f4b00d-2892-4e69-a498-d22d0ee86f26"></p>

이 알고리즘은 프로세스들을 CPU burst 성격에 따라 구분한다. 어떤 프로세스가 CPU 시간을 너무 많이 사용하면, 낮은 우선순위의 큐로 이동된다. 그리고 I/O 중심의 프로세스와 대화형 프로세스들은 높은 우선순위의 큐에 넣는다. 마찬가지로 낮은 우선순위의 큐에서 너무 오래 대기하는 프로세스는 높은 우선순위의 큐로 이동할 수 있다. 이러한 노화<sup>aging</sup> 형태는 **기아 상태를 예방**한다.

이 스케줄링 알고리즘은 설계 중인 특정 시스템에 부합하도록 구성이 가능해서 **일반적으로 OS에서 사용**되는 알고리즘이지만, 모든 매개변수 값을 선정하는 특정 방법이 필요하기 때문에 가장 복잡한 알고리즘이기도 하다.
