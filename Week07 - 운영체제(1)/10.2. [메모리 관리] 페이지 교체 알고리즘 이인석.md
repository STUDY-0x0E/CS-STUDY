# 페이지 교체

- 요구 페이징(Demand Paging) 과정에서 특정 프로세스가 전체 프로세스에 대해 프레임을 요구하면, 메모리가 과할당될 수 있다
- 빈 프레임이 있다면 해당 프레임을 사용하나, 빈 프레임이 없다면 페이지 교체 알고리즘을 통해 페이지를 희생시킨다

### OPT 알고리즘 or MIN 알고리즘

- 긴 주기 동안 사용하지 않는 페이지를 교체하는 방식
- 어떤 페이지에 어떤 기준으로 접근하는지 알지 못하기 때문에 사실상 구현 불가능한 알고리즘
- 이론상 가장 우수한 성능을 가지기 때문에 다른 알고리즘의 비교 용도로 사용함

### FIFO

- 가장 오래된 페이지 교체
- 페이지가 적재된 시간 기억
- 지역성에 대한 고려 없음 (오래된 페이지가 자주 사용될 수 있음)
    - 더 많은 프레임을 할당 받아도 페이지 폴트가 늘어날 수도 있음

### LRU

- 가장 오랜 기간 사용하지 않은 페이지 교체
- 마지막 페이지 참조 시간 기록
- 연결 리스트와 맵으로 구현 가능
    - 연결 리스트 : hit 되면 가장 앞으로, miss 되면 가장 뒤 제거 후 삽입
    - 맵 : 페이지 노드의 주소 저장

### LFU

- 가장 참조 횟수가 적은 페이지 교체
- 페이지 참조 시, 참조 횟수 누적

### MFU

- 가장 적은 참조 횟수 = 가장 최근 참조 = 앞으로 사용될 페이지 = 가장 많이 사용한 페이지 교체
- 잘 쓰이지 않음

### Clock Algorithm

- 페이지를 순차적으로 가리키는 포인터를 이동시키며 교체 결정
    - 처음에 모든 페이지의 refrence bit(r)를 1로 초기화
    - 할당된 페이지 순으로 r  = 1이면 0, 0이면 교체
    - 페이지가 참조되면 r = 1로 변경
    - 교체될 때까지 처음부터 반복

### Second Chance Algorithm

- Clock Algorithm에서 modifed bit(m)을 추가
- (r, m)에 따라 아래와 같이 판단
    - (0, 0) : 최근에 사용되지도, 변경되지도 않은 경우 ⇒ 제일 교체하기 좋은 페이지
    - (0, 1) : 최근에 사용되지는 않았지만, 변경된 경우 ⇒ 디스크 저장이 필요해 교체에 힘듦
    - (1, 0) : 최근에 사용되었으나 변경되지는 않은 경우 ⇒ 곧 다시 사용될 가능성이 높음
    - (1, 1) : 최근에 사용되고, 변경도 된 경우 ⇒ 디스크 저장도 필요하고, 다시 사용될 수 있음
- 처음에는 모든 페이지의 비트를 (1, 0)으로 초기화 / 아래로 변화
    - (1, 0) ⇒ (0, 0) , (0, 1) ⇒ (0, 0) , (1, 1) ⇒ (0, 1) , (0, 0) ⇒ 교체
    - (0, 1) ⇒ (0, 0)은 변경 내용이 있으므로 디스크 저장 필요

## 프레임 할당 전략

### 프레임 할당량 방식
- 동등 할당 : 모든 프로세스들에게 동등하게 프레임들을 똑같이 할당함
- 비례적인 할당 : 프로세스 크기에 따라 프레임을 차등 할당함

### 프레임 선택 할당 범위
- 지역 교체 : 프로세스 별로 할당된 프레임의 크기가 고정되어 있으므로, 페이지 폴트 발생 시 프로세스 안에서 페이지 교체 정책 시행
- 전역 교체 : 프로세스의 우선 순위를 따져, 각 프로스세스에게 동적인 우선 순위 할당을 진행하는 방식. 페이지 폴트 시 다른 프로세스의 프레임 선점 가능

## 스레싱

- 작업을 불러올 최소 페이지도 없어 과도하게 페이지 폴트가 발생해 성능이 저하되는 경우

### 스레싱 원인

- Multi-programming degree가 커지며 어떤 프로세스의 페이지인지 고려 없이 교체 수행
- 교체한 프레임이 해당 프로세스에서 필요한 페이지가 되면, 다시 해당 프로세스에서 페이지 폴트가 발생하고 다른 프로세스에서 프레임을 가져온다
- 스왑인과 페이지 교체가 계속 반복된다 ⇒ 페이지에 대한 큐잉이 진행되며 CPU 이용률이 낮아진다
- CPU 스케줄러는 CPU 이용률을 보고 Multi-programming degree를 더 증가시킨다
- 계속 단계가 반복되며 페이징하는데 모든 시간을 소요하고 전체적인 성능이 저하된다

### 스레싱 해결

- 지역 교체 알고리즘
    - 자신에게 할당된 프레임 세트에서만 교체를 수행
    - 다른 프로세스의 페이지를 침범하지 않음
- 메모리의 지역성 유지
    - 지역성을 포함하기에 충분한 프레임 제공
- Working-Set 알고리즘
    - Multi-programming degree 조절
    - 프로세스 별로 지역성을 위해 특정 크기로 윈도우 LRU
        - D = $\sum WS_i$일 때, D가 전체 메모리보다 커지면 프로세스 중 하나 종료 후 페이지 반환
        - D : 모든 프로세스 전체 요구량, WS : 프로세스 i의 프레임 요구치
