# 3. Processes

## 3.1. 프로세스의 개념

### 3.1.1. 프로세스란 무엇인가?

- 컴퓨터에서 실행 중인 프로그램
- 메모리에 적재된 프로그램
  
### 3.1.2. 프로세스의 구조<sup>Process Structure</sup>

<p align="center"><img width="25%" src="https://github.com/STUDY-0x0E/CS-STUDY/assets/39394642/f096b3de-eeba-4d86-a37d-a86c5bb7b8b7"></p>

- Code : 실행가능한 **코드**를 저장하는 공간
- Data
  - Data segment : **초기화된 전역 변수**와 static 변수가 저장되는 공간
  - BSS segment : **초기화되지 않는 전역 변수**와 static 변수가 저장되는 공간
- Heap : 프로그램 실행동안 **동적으로(malloc) 할당되는 변수**가 저장되는 공간
- Stack : 함수가 실행되는 동안 데이터를 일시적으로 저장하는 영역. 대표적으로 **함수 매개변수, 리턴 주소, 지역 변수** 등을 저장

### 3.1.3. 프로세스의 상태<sup>Process State</sup>

<p align="center"><img width="70%" src="https://github.com/STUDY-0x0E/CS-STUDY/assets/39394642/c90f1408-ad86-4b95-a932-79fde079c308"></p>

- New : 프로세스가 생성된 상태
- Ready : 프로세스가 프로세서에 의해 실행되기를 기다리는 상태(프로세스는 Ready Queue에서 실행을 준비하고 있음)
- Running : Ready Queue에 있는 프로세스가 프로세서에 의해 실행되는 상태
- Waiting : 프로세스 입/출력 이벤트가 발생되어 입/출력 처리가 완료될 때까지 기다리는 상태
- Terminated : 프로세스 실행이 종료되어 프로세스 할당이 해지된 상태

### 3.1.4. 프로세스 제어 블록<sup>Process Control Block, PCB</sup>

운영체제에서 각각의 프로세스는 PCB로 표현된다. PCB는 하나의 프로세스에 연관된 정보들을 포함하며 즉, 프로세스에 관한 정보 블록이다.

PCB에 포함된 정보들은 다음과 같다.

<p align="center"><img width="20%" src="https://github.com/STUDY-0x0E/CS-STUDY/assets/39394642/18273025-dac4-48bd-b6e5-04bac2fe6aaa"></p>

- 프로세스 상태(Process State): new, ready, running, waiting, terminated 상태 중 하나에 해당됨
- 프로세스 ID(Process ID): 프로세스 ID, 자식 프로세스 ID
- 프로그램 카운터(Program Counter): 프로세스에서 실행해야 할 다음 명령어 주소에 대한 포인터
- CPU 레지스터(CPU registers): IR(Instruction Register), DR(Data Register), PC(Program Counter) 등 프로세스를 실행하기 위해 저장해야 할 레지스터 정보
- CPU 스케줄링 정보(CPU-scheduling information): 프로세스 실행 순서를 정하는 정보
- 메모리 관리 정보(Memory-management information)
- 계정 정보(Accounting Information): 프로세스의 실행, 시간 제한, 실행 ID 등에 사용되는 CPU양의 정보
- I/O 상태 정보(I/O status information): 프로세스에 의해 할당된 I/O 디바이스 목록

### 3.1.5. 프로세스<sup>Process</sup>와 쓰레드<sup>Thread</sup>의 구분

**프로세스**는 실행 중인 프로그램을 말하며, 완벽히 독립적이기 때문에 메모리 영역(Code, Data, Heap, Stack)을 다른 프로세스와 공유하지 않는다. 프로세스는 최소 1개의 쓰레드(메인 쓰레드)를 가지고 있다.

**쓰레드**는 프로세스 내에서 Stack만 따로 할당 받고, 그 이외의 메모리 영역(Code, Data, Heap)영역을 공유하기 때문에 다른 쓰레드의 실행 결과를 즉시 확인할 수 있다. 쓰레드는 프로세스 내에 존재하며 프로세스가 할당받은 자원을 이용하여 실행된다.

## 3.2. 프로세스의 스케줄링<sup>Process Scheduling</sup>

### 3.2.1. 멀티 프로그래밍<sup>Multiprogramming</sup>과 시분할 시스템<sup>Time Sharing System</sup>의 목적

**멀티프로그래밍**의 목적은 동시에 여러 프로세스를 실행하여 CPU의 효율을 극대화하는 것이다.

**시분할 시스템**의 목적은 프로세스들 사이에서 CPU Core를 빈번하게 교체하여 사용자가 각각의 프로그램이 동시에 수행되는 것처럼 느끼게 하는 것이다.

### 3.2.2. 스케줄링 큐<sup>Scheduling Queues</sup>

위 목적을 달성하기 위해 **프로세스 스케줄러**는 CPU에서 실행 가능한 프로세스들 중 하나를 선택한다.

- 프로세스들이 Ready 상태이고 CPU Core 위에서 실행하기 위해 기다릴 때, 프로세스들은 **Ready Queue**에 삽입된다.
- 특정한 이벤트가 발생되기를 기다리는 프로세스들은 **Wait Queue**에 위치한다.

큐에서 프로세스의 흐름은 일반적으로 다음과 같다.

<p align="center"><img width="65%" src="https://github.com/STUDY-0x0E/CS-STUDY/assets/39394642/0810c416-6bb6-4f90-a244-0fda2eee078c"></p>

### 3.2.3. 문맥 교환<sup>Context Switch</sup>란?

프로세스에서 **문맥**<sup>Context</sup>이란 마지막에 수행했던 명령어 위치이다.

**문맥 교환**은 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 제어를 다른 프로세스에 넘겨야 할 때 발생한다. 즉, 문맥 교환은 **PCB를 교환하는 과정**을 말한다.

프로세서의 레지스터에 있던 내용은 나중에 다시 사용할 수 있도록 **PCB**에 저장된다.

문맥 교환 동안에는 PCB의 이전 상태를 저장하는 등 CPU가 일을 하지 못하기 때문에, 문맥 교환이 자주 일어난다면 **성능 저하를 유발**할 수 있다.

**쓰레드의 경우**는 문맥 교환에 있어서 프로세스보다는 좋은 성능을 낼 수 있다. 이미 쓰레드 자체가 **프로세스 내의 대부분을 공유**하고 있기 때문이다. 따라서 이전 상태값을 전부 저장하거나 할 필요가 없어지고, 문맥 교환에 따른 성능 저하가 줄어들 수 있다.

## 3.3. 프로세스들의 연산들<sup>Operations on Processes</sup>

### 3.3.1. 부모 프로세스<sup>Parent Process</sup>와 자식 프로세스<sup>Child Process</sup>

운영체제는 **프로세스의 생성과 종료**를 수행한다.

하나의 프로세스는 여러 개의 새로운 프로세스를 생성할 수 있다.

기존에 생성한 프로세스를 **부모 프로세스**<sup>Parent Process</sup>라 하고, 기존에 생성한 프로세스에 의해 새롭게 생성된 프로세스를 **자식 프로세스**<sup>Child Process</sup>라 한다.

자식 프로세스는 **부모 프로세스의 복사본**으로 구성된다.

### 3.3.2. 부모 프로세스와 자식 프로세스의 실행관계

<p align="center"><img width="90%" src="https://github.com/STUDY-0x0E/CS-STUDY/assets/39394642/9ef82dbb-a04e-4350-bfc9-2de096d2044a"></p>

1. 부모 프로세스는 fork() 함수로 자식 프로세스 번호를 반환받고 wait()함수로 인하여 대기한다.
2. 자식 프로세스가 생성되고 fork() 함수 이후의 문장을 수행한다.
3. exit() 함수가 호출되어 자식 프로세스가 종료된다.

### 3.3.3. 프로세스의 종료

1. 프로세스는 마지막 문장을 실행할 때 종료된다.
2. exit() 시스템 콜을 통해 운영체제가 강제 종료한다.
3. 프로세스가 종료되면 운영체제는 메모리, 파일, I/O 버퍼 등의 자원을 해제한다.

### 3.3.4. 좀비 프로세스<sup>Zombie Process</sup>와 고아 프로세스<sup>Orphan</sup>

- 좀비 프로세스<sup>Zombie Process</sup>: 실행이 종료되었지만 아직 삭제되지 않은 프로세스
- 고아 프로세스<sup>Orphan Process</sup>: 부모 프로세스가 자식 프로세스보다 먼저 종료된 프로세스

## 3.4. 프로세스 간 통신<sup>Inter-Process Communication, IPC</sup>

### 3.4.1. IPC<sup>Integer-Process Communication</sup>란?

프로세스들은 서로 독립적이거나 상호협력적으로 동시에 실행된다.

**독립적인 프로세스**는 프로세스끼리 자원을 공유하지 않고, **상호협력적인 프로세스**는 다른 프로세스들과 자원을 공유하므로 영향을 줄 수 있다.

상호협력적인 프로세스 간의 의사소통을 **IPC**라고 한다.

### 3.4.2 IPC 종류

IPC의 종류로는 파이프, 공유 메모리, 메세지 큐, 소켓, PRC 등이 있다.

**파이프**<sup>Pipe</sup>

- **통신을 위한 메모리 공간(pipe)를 생성**하여 프로세스가 데이터를 주고 받게 한다.
- 파이프가 두 개의 프로세스를 연결하여 **하나**의 프로세스는 **데이터를 쓰기**만, **다른 하나**는 **데이터를 읽기**만 할 수 있기 때문에 **반이중<sup>Half-Duplex</sup> 통신**이라고 부르기도 한다.
- 프로세스가 읽기와 쓰기 통신을 모두 해야한다면, pipe를 두 개 만들어야 하므로 구현히 복잡해질 수 있다. 전이중 통신을 고려해야할 상황이라면 좋은 선택이 아니다.
 
**공유 메모리**<sup>Shared Memory</sup>

- 공유 메모리가 데이터 자체를 공유하도록 지원하는 설비이다. **프로세스 간 메모리 영역을 공유해서 사용**할 수 있도록 허용한다.
- **프로세스가 공유 메모리 할당을 커널에 요청하면 해당 프로세스에 메모리 공간을 할당**해주고 이후 어떤 프로세스건 해당 메모리 영역에 접근할 수 있다.
- 프로세스 간 Read와 Write를 모두 필요로 할 때 사용한다.
- 장점은 중개자 없이 곧바로 메모리에 적용할 수 있기 때문에 모든 IPC 중 가장 빠르다.
- 단점은 메시지 전달 방식이 아니기 때문에 데이터를 읽어야 하는 시점을 알 수 없다.

**메시지 큐**<sup>Message Queue</sup>

- 메시지 큐는 **메모리를 사용한 pipe**이다.
- pipe나 fifo와 달리, **다수의 프로세스 간 메시지를 전달**할 수 있다.
- 공유 메모리를 통해 IPC를 구현할 때 쓰기 및 읽기 빈도가 높으면 동기화 때문에 기능 구현이 매우 복잡해지는데, 이때 대안으로 메시지큐를 사용하기도 한다.

**소켓**<sup>Socket</sup>

- Unix 도메인 소켓 또는 IPC 소켓은 동일한 호스트 운영 체제에서 실행되는 프로세스 간의 데이터 교환을 위한 데이터 통신 엔드 포인트이다.
- 네트워크 소켓 통신을 통해 데이터를 공유한다.
-   - 데이터 교환을 위해 양쪽 PC에 각각 임의의 포트를 정하고 해당 포트 간의 연결을 통해 데이터를 주고받는다.
    - 이때 각각 PC의 포트를 담당하는 소켓이 각각 하나의 프로세스이다.
    - 서로 다른 PC의 두 프로세스가 확인 과정을 거쳐 **1대 1로 데이터를 주고 받는 방식**이다.
  - **원격**에서 프로세스 간 데이터를 공유할 때 사용한다.
  - **전이중<sup>Full Duplex</sup>(양방향) 통신**이 가능하다.
  - 서버/클라이언트 환경을 구축하는 데 용이하다.
  - 중대형 애플리케이션에서 주로 사용한다.

**PRC**<sup>Remote Procedure Call</sup>

- RPC는 분산 네트워크 망에서 많이 사용되는 방식이다.
- 별도의 원격 제어를 위한 코딩없이 다른 주소 공간에서 함수나 프로시저를 실행할 수 있게 하는 프로세스 간 통신 기술이다.
- 분리된 PC에 저장된 데이터를 마치 내 PC에 존재하는 것처럼 사용할 수 있다.
