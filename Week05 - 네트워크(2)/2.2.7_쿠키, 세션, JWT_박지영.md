# 2.2 네트워크

서버가 클라이언트 인증을 확인하는 방식은 대표적으로 쿠키, 세션, 토큰 3가지가 있다.

## 쿠키(Cookie)
<p align="center"><img width="50%" src="https://github.com/STUDY-0x0E/CS-STUDY/assets/39394642/b0bc7236-2a4f-4937-8264-d98c15ea7f28"></p>

웹브라우저에서 쿠키(Cookie)는 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각으로, key=value 형식의 문자열 데이터 묶음이다.

브라우저는 이 문자열 데이터 조각들을 저장해놓았다가 **동일한 서버에 재요청시 쿠키 데이터를 전송**할 수 있다.

HTTP 프로토콜은 기본적으로 stateless하기 때문에 **서버와 클라이언트 간의 연결 유지**를 구현하기 위해 서로를 인식할 수 있는 식별데이터인 쿠키를 사용한다.

쿠키는 크게 세션관리, 개인화, 트래킹에 사용된다.

1. 세션관리: 로그인 유지, 장바구니 유지 등
2. 개인화: 다크모드 사용, 언어 설정, 메뉴 순서 최적화 등
3. 트래킹: 분석데이터 수집, 리타게팅 광고에 사용 등
   
### 쿠키 인증 방식

<p align="center"><img width="50%" src="https://github.com/STUDY-0x0E/CS-STUDY/assets/39394642/7e07b365-c767-4d93-b5ec-a5463541ce36"></p>

1. 브라우저(클라이언트)가 서버에 요청을 보낸다.
2. 서버는 클라이언트의 요청에 대한 응답을 작성할 때, 클라이언트 측에 저장하고 싶은 정보를 응답 헤더의 Set-Cookie에 담는다.
3. 이후 해당 클라이언트는 요청을 보낼 때마다, 매번 저장된 쿠키를 요청 헤더의 Cookie에 담아 보낸다.
 

### 쿠키 인증 방식의 단점

1. 보안에 취약: 요청시 쿠키의 값을 그대로 보내기 때문에 유출, 조작 당할 위험이 존재함
2. 용량 제한: 용량 제한이 있어 많은 정보를 담을 수 없음
3. 브라우저간 공유 불가능: 웹 브라우저마다 쿠키에 대한 지원 형태가 다르기 때문에 브라우저간 공유 불가능
4. 네트워크 부하: 쿠키의 사이즈가 커질수록 네트워크에 부하가 심해짐

## 세션(Session)

세션은 클라이언트의 중요한 정보를 **서버측에서 관리**하는 방식이다.

**클라이언트는 쿠키를 통해 세션ID를 기억**한다.

### 세션 인증 방식

<p align="center"><img width="50%" src="https://github.com/STUDY-0x0E/CS-STUDY/assets/39394642/555c9cd1-442d-48de-90f6-5ba58d8c606c"></p>

1. 사용자가 로그인을 요청한다.
2. 서버에서 계정 정보를 읽어 사용자를 확인한다.
3. 사용자에 고유한 Id를 부여하여 세션 저장소에 저장한다.
4. 세션 저장소와 연결된 세션Id를 발급한다.
5. 사용자는 서버에서 해당 세션Id를 받아 쿠키에 저장한다.
6. 사용자는 인증이 필요한 요청마다 쿠키를 헤더에 실어 보낸다.
7. 서버는 쿠키를 받아 세션 저장소에서 대조한다.
8. 세션 저장소에서 사용자 정보와 대응되는 정보를 가져온다.
9. 인증이 완료되면 서버는 사용자에 맞는 데이터를 보내준다.

### 세션 인증 방식의 단점

1. 보안 한계: 탈취자가 세션Id 자체를 탈취하여 클라이언트인척 위장할 수 있다는 보안의 한계점이 있다.
2. 서버 부하: 서버에서 세션 저장소를 사용하므로 요청이 많아지면 서버에 부하가 심해진다.


## JWT(Json Web Token)

JWT은 인증에 필요한 정보들을 암호화시킨 JSON 토큰을 의미한다.

JWT는 JSON 데이터를 **Base64 URL-safe-Encode**를 통해 인코딩을 직렬화 한것이며, 토큰 내부에는 위.변조 방지를 위해 개인키를 통한 **전자서명**도 들어가있다.

따라서 **서버는 무언가를 기억하지 않고**있다가 사용자가 JWT를 서버로 전송하면 **서명을 검증**하는 과정을 거치고 검증이 완료되면 요청한 응답을 돌려준다.

### JWT 구조

<p align="center"><img width="50%" src="https://github.com/STUDY-0x0E/CS-STUDY/assets/39394642/e6134f4b-42d2-45f6-bb69-3d6ebe9e5131"></p>

JWT는 .을 구분자로 인코딩 또는 암호화된 Header, Payload, Signature의 세가지 데이터로 나누어진다.

- **Header**: JWT에서 사용할 타입, 해시 알고리즘의 종류
- **Payload**: 서버에서 첨부한 사용자 권한 정보와 데이터(Payload는 해독이 가능하기 때문에 중요한 정보를 포함하면 안됨)
- **Verify Signature**: Header, Payload와 Header를 인코딩하고 개인키로 서명한 후 Header에 명시된 해시 함수를 적용한 전자서명


### JWT 인증 방식

<p align="center"><img width="50%" src="https://github.com/STUDY-0x0E/CS-STUDY/assets/39394642/ef0512b0-ece9-4d96-9fb5-a72af30da28a"></p>

1. 사용자가 로그인 한다.
2. 서버에서는 계정 정보를 읽어 사용자 확인 후, 사용자 고유ID값과 기타 정보를 Payload에 넣는다.
3. 서버는 암호화할 SECRET KEY를 이용하여 Access Token을 발급 한다.
4. 사용자는 Access Token을 받아 로컬 스토리지(혹은 쿠키)에 저장한다.
5. 사용자는 이후 인증이 필요한 요청마다 토큰을 헤더에 실어서 보낸다.
6. 서버에서는 해당 토큰의 Verify Signature를 SECRET KEY로 복호화한 후 조작여부, 유효기간을 검증한다.
7. 검증이 완료되면, Payload를 디코딩하여 사용자의 ID에 맞는 데이터를 가져온다.

## 장단점

||장점|단점|
|---|---|---|
|**Cookie&Session**|- Cookie만 사용하는 방식보다 보안 향상<br>- 서버 쪽에서 Session 통제 가능<br>- 네트워크 부하 낮음|- 세션 저장소 사용으로 인한 서버 부하|
|**JWT**|- 인증을 위한 별도의 저장소가 필요 없음<br>- 별도의 I/O 작업없는 빠른 인증 처리<br>- 확장성이 우수함(플랫폼 독립적)|- 토큰의 길이가 늘어날수록 네트워크 부하<br>- 특정 토큰을 강제로 만료시키기 어려움|

JWT는 stateful해서 **통제가 어렵고 토큰이 탈취당한 경우 무효화할 방법이 없다**. 이를 보완하기 위해 access 토큰과 refresh 토큰을 부여하는 방식을 사용하기도 한다.

### access 토큰과 refresh 토큰

access 토큰은 수명이 몇 시간 혹은 몇 분 이하로 짧고 refresh 토큰은 2주 정도 비교적 수명이 긴 토큰이다.

<p align="center"><img width="50%" src="https://github.com/STUDY-0x0E/CS-STUDY/assets/39394642/989b49e2-5dab-472d-80db-5219b23abcf0"></p>

1. access 토큰과 refresh 토큰을 발급하고 클라이언트에게 보냄
2. 서버는 refresh 토큰의 상응값을 DB에 저장
3. 이후 사용자의 access 토큰이 수명을 다하면 사용자는 refresh 토큰을 서버에 보냄
4. 서버는 해당 토큰을 DB의 값과 대조해보고 맞다면 새로운 access 토큰을 발급

##  Session과 Refresh Token

### Session과 Refresh Token의 차이점

||Cookie&Session|Access Token&Refresh Token|
|---|---|---|
|**유효 기간**|일반적으로 세션은 **짧은 유효 기간**을 가지며 사용자가 웹 애플리케이션에 로그인할 때 생성되고, 사용자가 로그아웃하거나 세션이 만료되면 무효화된다.|보통 **세션보다 더 오래 유지**된다. Refresh Token을 사용하여 액세스 토큰을 주기적으로 갱신할 수 있으므로, 사용자는 계속해서 로그인 세션을 유지하지 않아도 된다.|
|**보안**|세션은 **사용자의 브라우저 쿠키 또는 서버 측 세션 저장소**에 저장된다. 따라서 쿠키 변조나 중간자 공격과 같은 공격에 노출될 수 있다.|Refresh Token은 일반적으로 Access Token과 별도로 저장되며 민감한 정보가 노출되지 않도록 보다 안전하게 관리된다. 또한 Refresh Token을 사용하면 액세스 토큰을 갱신할 때에만 인증 서버와 통신하므로 **보안 향상에 도움**이 된다.|
|**범용성**|세션은 특정 웹 애플리케이션 또는 서비스와 관련이 있으며 **다른 애플리케이션에서 사용하기 어렵다.**|Refresh Token은 주로 OAuth 2.0 및 인가 프로토콜에서 사용된다. **다른 애플리케이션 및 서비스에서도 동일한 Refresh Token을 사용하여 인증 및 인가를 관리할 수 있습니다.**|

세션은 주로 **웹 애플리케이션의 로그인 및 로그아웃 관리**에 사용되며, Refresh Token은 보다 긴 유효 기간과 높은 보안 수준을 제공하여 **사용자의 자동 로그인 및 다른 서비스와의 통합**에 유용하다. 사용 목적과 보안 요구 사항에 따라 방식을 선택하게 된다.
