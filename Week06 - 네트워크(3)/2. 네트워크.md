# 네트워크

<br>



> 이인석

<details><summary>라우터에 대해서 설명</summary>

네트워크와 네트워크를 연결하는 3계층(네트워크 계층) 네트워크 기기
- 패킷의 도착지를 읽어 어느 네트워크로 전송하면 좋을지(최적 경로) 결정하는데, 이것을 라우팅이라고 한다
- NAT, 방화벽, VPN, QoS 등의 부가 기능을 제공하기도 한다 => 1, 2, 3 계층 역할 수행 담당

</details>

<details><summary>IP주소 할당 프로토콜에 대해 설명</summary>

DHCP => 호스트가 네트워크에 연결될 때마다 임시 IP 제공

동작 과정
1. 연결된 호스트는 브로드 캐스팅(UDP)을 통해 DHCP 서버를 찾는다 => IP가 없으므로 MAC 활용
2. DHCP 서버에서 서버 IP와 클라이언트 IP 제안 정보를 회신한다
3. 클라이언트는 서버 IP를 통해 제안 받은 클라이언트 IP에 대해 사용 요청을 보낸다
4. DHCP 서버는 받은 요청에 대해 ACK를 보내서 요청을 마무리 한다

</details>

<details><summary> 공인 IP주소와 사설IP 주소 매핑하는 방법(작동 방식) </summary>
  
외부에서 온 통신에서 목적지 주소를 매핑 테이블을 확인하여 내부의 호스트의 주소로 NAT가 변경합니다.
내부에서 외부로의 통신의 경우도 출발지 주소를 NAT를 통해서 외부 주소로 변경하여 보냅니다.

외부에서 하나의 IP 주소에서 대해 내부에서 여러 IP 주소로 사용하는 경우, 포트 번호를 활용하여 포트 번호를 매핑 테이블에 포함하여 변환을 동시에 수행합니다. (NAPT)

학교 강의 자료인데, 이해에 도움이 될 것 같아 첨부합니다.

![NAT 작동](https://github.com/STUDY-0x0E/CS-STUDY/assets/66675919/85307038-241a-433d-a9a8-05af0290163a)

![NAPT](https://github.com/STUDY-0x0E/CS-STUDY/assets/66675919/b17890a0-a388-4c4a-9df2-705923dc228f)
</details>

<details><summary>IP란 무엇이고 역할에 대해서 설명</summary>

IP 프로토콜
- 지정한 IP 주소에 데이터 전달하기 위한 프로토콜
- 패킷 단위 통신

IP 주소  
네트워크 내에서 해당 호스트(노드)를 식별하는 유일한 주소  
  
  - MAC : 하드웨어를 식별할 수 있는 물리적인 식별자
  - Port : 프로세스의 식별자  

네트워크를 구분하기 위한 네트워크 식별자와 호스트를 구분하기 위한 호스트 식별자로 구성  
식별자를 통해 연결된 장치를 

</details>

<details><summary>IP 주소 체계에 대해서 설명</summary>

IPv4
- 32비트로 2^32개 사용 가능한 주소 체계
- 호스트가 속한 네트워크 부로 호스트의 주소인 호스트 부로 나뉜다

서브넷
- 라우터와 호스트를 연결하는 부분 네트워크

서브넷 마스크
- 서브넷 내의 IP를 결정 짓는 규칙
- xxx.xxx.xxx.xxx/x의 형식으로 표현되며 마지막 수를 통해 상위 비트를 결정한다
  - 숫자에 해당하는 상위 비트를 모두 1 나머지를 0으로 하면 AND 연산을 통해 네트워크 부와 호스트 부를 추출할 수 있다.

![image](https://github.com/STUDY-0x0E/CS-STUDY/assets/66675919/020bfc09-9406-4d64-be91-8e618855b43a)

![image](https://github.com/STUDY-0x0E/CS-STUDY/assets/66675919/2a4e0592-7206-4711-aec9-b5f17abe7f15)
</details>

<details><summary>네트워크 계층에서 IP 프로토콜을 사용하는 이유</summary>

데이터를 전송하면서 최종 목적지에 도착할 수 있도록 라우팅 해주는 것이 네트워크 계층입니다.  
이 과정에서 어느 목적지에 전송할지 논리적인 주소인 IP 주소를 통해 최적 경로를 라우팅할 수 있게 IP 프로토콜을 사용합니다.

</details>

<details><summary>HTTP1.1 과 HTTP2.0의 차이</summary>

HTTP 1.1은 keep alive를 통해서 한 번의 3-way handshake 이후로 반복적으로 발생하는 것을 막아 RTT를 감소시켰으나 네트워크 내의 같은 큐에 있는 패킷의 크기에 따라 다른 패킷이 지연(TCP는 순서 보장이 이뤄지므로)되는 HOL Blocking (Head Of Line Blocking)이 발생했습니다.  

HTTP 2.0은 이러한 문제를 해결하기 위해서 Multiplexed 기술을 도입하는데, 1개의 세션으로 여러 요청을 순서에 상관없이 여러 개의 Stream으로 받아 단일 연결 내에서도 동시에 여러 메시지를 받을 수 있게 했습니다.

</details>

<details><summary>패킷을 주고 받는 방식</summary>

패킷의 송수신처의 IP 주소와 MAC 주소가 결정되면 라우팅을 통해서 어떤 경로로 갈지 결정하게 됩니다.  
그 과정에서 각각의 라우터는 패킷을 받고, 자신의 위치에서 수신처로 보내기 위해 라우팅을 진행합니다.  

하지만 라우터는 모든 네트워크의 주소를 알지 못하기 때문에 다음 라우터 MAC 주소를 수신처로 정하고, IP를 최종 수신처로 설정하여 다음 라우터로 라우팅을 진행합니다. 이렇게 라우터에서 라우터를 거치면서 홉 바이 홉 통신을 통해서 패킷은 최종 IP 주소지에 도착하게 됩니다.  

</details>

<details><summary>HTTP2.0의 멀티플렉싱에 대해 설명</summary>

HTTP 2.0은 HTTP 1.x보다 지연 시간을 줄이고 응답 시간을 더 빠르게 하기 위해 멀티 플렉싱, 헤더 압축, 서버 푸시, 요청의 우선 순위와 같은 기능을 지원하는 프로토콜입니다.

멀티 플렉싱은 기존의 HTTP 1.x 방식에서 데이터당 한 번의 연결이 발생하여 나타나는 지연 시간을 해결하기 위한 방법으로 한 번의 요청에 대해 각 데이터를 각각의 병렬 스트림으로 송수신을 진행하여 특정 스트림에 대한 문제는 해당 스트림에 대해서만 영향을 미치도록 진행하여 빠르게 송수신을 할 수 있도록 하는 방법입니다.

</details>

<details><summary>흐름제어와 혼잡제어에 대해 설명</summary>

TCP 통신에서 패킷 손실, 순서 바뀜 등의 문제가 발생할 수 있는데, 이런 문제를 해결하기 위한 방법으로 흐름 제어와 혼잡 제어가 있습니다.

흐름 제어  
- 송신측과 수신측 사이의 데이터 처리 속도 차이를 해결하기 위한 방법
- 송신측의 전송량이 수신측의 처리량 보다 클 경우 수신측의 큐를 초과하여 패킷 손실이 발생할 수 있으므로 제어가 필요

1. Stop And Wait  
- 매번 전송한 패킷에 대해서 확인 응답을 받아야만 다음 패킷 전송을 진행하는 방식
- 피드백 손상과 중복 전송을 우려하여 순서번호를 활용한다
- 무조건 하나의 패킷에 대한 수신에 대해 ACK를 받아야 진행하므로 비효율적이고 지연 시간이 크다

2. Go-Back-N ARQ  
![image](https://github.com/STUDY-0x0E/CS-STUDY/assets/66675919/17d10eb9-4b3e-449f-b073-d90b4a2e0aeb)

- 동작 방식  
  - 송신 윈도우(2^m - 1 크기, m은 순서번호 필드 비트 수)만큼 송신을 진행하고, 수신측에서 ACK를 수신하면 해당 데이터를 송신 윈도우에서 제거하고 다음 데이터로 범위를 늘려 송신 진행(윈도우 이동)
  - 만약 수신자가 데이터를 순서대로 받지 못하거나, 수신 받지 못하여 ACK가 오지 않는다면 마지막 ACK 다음 데이터를 모두 폐기하고 재전송
  - 구현이 간단하나 불필요한 재전송이 발생할 수 있음  
- 세그먼트를 하나씩 수신하므로 수신 윈도우의 크기는 1이 됨

3. Selective Repeat  
![image](https://github.com/STUDY-0x0E/CS-STUDY/assets/66675919/46838995-354c-4a7e-a703-461cc1acf96d)
- 동작 방식
  - 누적 ACK(누적되는 순서 번호가 맞는 ACK)가 수신되면 송신 윈도우를 ACK만큼 이동
  - 비누적 ACK(누적되는 순서 번호가 맞지 않는 ACK)가 수신되면 해당 세크먼트의 수신 사실 기록
  - 세그먼트 재전송 타이머가 종료될 때까지 ACK가 수신되지 않으면 해당 세그먼트 재전송(오류가 발생한 세그먼트에 대해서만 전송함) 
  - 수신자는 누적 정상 세그먼트를 수신하면 수신 윈도우를 이동하고, 비누적 정상 세그먼트를 수신하면 ACK를 회신하고 해당 세그먼트는 버퍼에 유지
- 비교적 성능이 좋으나, 구현이 어려움

혼잡 제어
- 트래픽 증가로 인해 발생하는 큐잉 지연 및 오버 플로우를 낮추는 방법
- 네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송 속도를 강제로 줄이는 방법

1. Slow Start  
송신 윈도우 크기를 1로 시작하며 패킷이 문제없이 도착하면 각각의 패킷마다 송신 윈도우의 크기를 1씩 증가시킨다.  
결과적으로 한 번의 전송 주기가 끝나면 송신 윈도우의 크기가 2배씩 증가한다 => 지수적 증가  
타임 아웃 발생 시, 임계치를 윈도우의 절반으로 설정한다  
윈도우가 인계치에 도달하면 혼잡 회피에 진입한다

2. Congestion Avoidance (혼잡 회피)  
윈도우가 임계치에 도달하면 RTT마다 윈도우의 크기를 1씩 증가 시켜 선형적으로 증가시킨다

3. Fast Retransmit (빠른 재전송)  
수신측에서 도착해야할 순서 번호의 패킷이 도착하지 않고 다음 패킷이 도착한 경우 ACK 패킷을 제대로 도착한 패킷의 다음 순서 번호를 ACK에 담아 보낸다.  
중복된 순번의 ACK가 3번 도착하게 되면 송신측에서는 경미한 혼잡이 발생한 것으로 판단하고, 재전송을 진행하고 윈도우의 크기를 감소시킨다.

4. Fast Recovery (빠른 회복)  
혼잡이 발생한 경우 임계치의 크기를 현재 윈도우의 1/2로 설정한다.  
손실된 세그먼트를 재전송하고, 임계치의 크기를 3 늘린다.
여전히 중복 ACK가 수신될 경우 윈도우의 크기를 1씩 늘린다.
정상 ACK가 수신될 경우 현재 윈도우의 크기를 임계치로 설정하고, 혼잡 회피에 진입한다.

![image](https://github.com/STUDY-0x0E/CS-STUDY/assets/66675919/06e8d0bc-5fa4-4331-9046-790b321308a2)

</details>

<br>



> 차우열

<details><summary>OSI 7계층에 대해서 간략하게 설명</summary>
  응용, 표현, 세션, 전송, 네트워크, 링크,물리 …
</details>

<details><summary>전송 계층에서 사용되는 프로토콜</summary>
  TCP와 UDP
</details>

<details><summary>네트워크 계층에서 쓰이는 단위(PDU)</summary>

</details>

<details><summary>TCP 3-way-handshake 과정</summary>
  클라이언트는 서버에 SYN전송, 서버가 클라이언트 SNY+1, ACK, ...
</details>

<details><summary>3way-handshake 장점 </summary>
  연결을 확인해서 데이터를 확실하게 전달, 신뢰성있는 통신 보장, 연결 요청
</details>

<details><summary> 로드밸런싱에 대해서 설명 </summary>
  부하를 분산하는 역할
</details>

<details><summary> 4-way-handshake 는 어느 경우에 사용되는지 </summary>
  통신 연결을 종료하는 경우에 사용
</details>

<details><summary> 어떤 방식으로 진행되는지 설명 </summary>
  ...
</details>

<details><summary> Close wait, Time wait 왜 진행되는지 </summary>
  ...
</details>

<br>




> 박지영

<details><summary> 쿠키란 무엇인가요? </summary>
  <br>
  쿠키는 서버가 사용자의 웹 브라우저에 전송하는 데이터 조각으로, key=value형식의 문자열 데이터 묶음입니다.<br>
  HTTP 프로토콜은 Stateless하기 때문에 서버와 클라이언트 간의 연결 유지를 구현하기 위해 서로를 인식할 수 있는 식별 데이터인 쿠키를 사용합니다.
</details>

<details><summary> 쿠키는 어디에 사용되나요? </summary>
  <br>
  쿠키는 세션 관리, 개인화, 트래킹에 사용됩니다. <br>
  로그인이나 장바구니 유지, 다크모드 혹은 언어 설정, 사용자의 데이터 수집을 통해 리타게팅 광고 등의 사례가 있습니다.
</details>

<details><summary> 쿠키와 세션의 차이점은 무엇인가요? </summary>
  <br>
  쿠키는 클라이언트의 웹 브라우저에 저장되고 세션은 서버에 있는 세션 저장소에 저장됩니다.
</details>

<details><summary> 언제 세션 대신 쿠키를 사용하나요? </summary>
  <br>
  세션은 서버의 자원을 사용하기 때문에 서버의 메모리와 속도 측면에서 쿠키가 유리한 경우가 있습니다.
</details>

<details><summary> HTTP 프로토콜이 Stateless한 것이 보완해야 될 약점인가요? </summary>
  <br>
  stateless하다는 것은 서버가 클라이언트의 상태를 저장하지 않는 것을 뜻합니다.<br>
  서버에 상태를 저장하지 않으므로 서버 확장이 용이하다는 장점이 있으나 클라이언트가 연결을 위한 데이터를 추가 전송해야한다는 단점이 있습니다.<br>
  그렇기 때문에 쿠키, 세션 등을 이용하여 최소한으로 상태를 유지할 수 있도록 해야 합니다.
</details>

<details><summary> TCP와 UDP 차이는 무엇인가요? </summary>
  <br>
  TCP는 신뢰성이 높고 전송 속도가 상대적으로 느리며 헤더 크기가 상대적으로 큽니다.<br>
  UDP는 데이터 손실이나 순서 뒤바뀜의 가능성이 있고 전송 속도가 빠르며 헤더 크기가 작습니다.
</details>

<details><summary> TCP와 UDP는 어떤 경우에 사용되나요? </summary>
  <br>
  TCP는 이메일 전송, 파일 전송과 같은 신뢰성 높은 연결을 위해 사용하고, UDP는 스트리밍, DNS와 같은 빠른 속도가 필요한 연결을 위해 사용합니다.
</details>

<details><summary> UDP는 신뢰성이 없는 건가요? </summary>
  <br>
  UDP는 각 패킷이 독립적으로 최적의 경로를 선택하여 이동하는 데이터그램 패킷 교환 방식을 사용하기 때문에 도착 순서가 달라지거나 데이터가 손실될 가능성이 있습니다.
</details>

<br>



> 박진아

<details><summary> HTTP1.0 에 대해서 설명 </summary>
    RTT시간이 걸린다.
</details>

<details><summary> HTTP 메소드에서 GET과 POST차이 </summary>

  - ET은 데이터를 읽어오는 메소드 (URL로 접근 가능, 용량 제한, 멱등성), POST는 데이터를 생성(바디 존재, URL요청 불가능, 보안성이 높다)
  
  -   GET도데이터를 보낼 수도 있다.
  
  -   차이점을 물어볼 경우 기능적으로 대답 권장
</details>

<details><summary> HTTP의 다른 메소드  </summary>
    DELETE는 데이터 삭제,  PUT는 데이터 변경
</details>

<details><summary> JWT에 대한 설명 </summary>
  
  인증과 인과 정보, 헤드(헤시 알고리즘) 페이로드(사용자 정보) 시그니처(헤더와 페이로드를 암호화 할 수 있는 공개키)로 구성되어 있다. 

  범용성이 좋아서 다른 서비스간의 통신 이점
</details>

<details><summary> 쿠키, 세션과 JWT 방식의 차이 </summary>

  JWT는 저장소를 따로 관리하지 않아도 사용자의 인증이 가능하다.
</details>

<details><summary> 어느 경우에 사용하면 되는지 설명 </summary>
  
  JWT의 단점은 … 취약하다. 보안이 중요한 작업 (은행) 세션으로 관리한다. 일반 로그인 같은 경우는 JWT .. 극복할 수 있다.
</details>

<details><summary> TCP/IP 계층에서 어플리케이션 계층에서 사용되는 프로토콜 </summary>
  
    HTTP(컴퓨터), DNS
</details>

<br>



> 남혜미

<details><summary> 주소창에 구글을 입력했을 때 발생하는 과정 </summary>
  
  (DNS (도메인) 와 HTTP 중 하나에 포커싱을 맞춰서 대답)
</details>

<details><summary> DNS의 역할 </summary>
  Domain name 과 IP주소를 매핑해준다.
</details>

<details><summary> TCP/IP 4계층에 대해서 설명 </summary>
  응용 계층, 전송 계층, 인터넷 계층, 링크 계층
</details>

<details><summary> HTTP와 HTTPS의 차이 </summary>
  
  HTTP의 보안 문제를 해결하기 위해 TSL/SSL을 적용하여 데이터를 암호화한게 HTTPS이다.
</details>

<details><summary> 프로토콜에 대해 설명 </summary>
  서로 다른 기기에서 데이터(메시지)를 원할하게 주고 받기 위한 통신 규약 및 약속이다.
</details>


