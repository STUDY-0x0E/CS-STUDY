# 네트워크

<br>



> 이인석

<details><summary>라우터에 대해서 설명</summary>

네트워크와 네트워크를 연결하는 3계층(네트워크 계층) 네트워크 기기
- 패킷의 도착지를 읽어 어느 네트워크로 전송하면 좋을지(최적 경로) 결정하는데, 이것을 라우팅이라고 한다
- NAT, 방화벽, VPN, QoS 등의 부가 기능을 제공하기도 한다 => 1, 2, 3 계층 역할 수행 담당

</details>

<details><summary>IP주소 할당 프로토콜에 대해 설명</summary>

DHCP => 호스트가 네트워크에 연결될 때마다 임시 IP 제공

동작 과정
1. 연결된 호스트는 브로드 캐스팅(UDP)을 통해 DHCP 서버를 찾는다 => IP가 없으므로 MAC 활용
2. DHCP 서버에서 서버 IP와 클라이언트 IP 제안 정보를 회신한다
3. 클라이언트는 서버 IP를 통해 제안 받은 클라이언트 IP에 대해 사용 요청을 보낸다
4. DHCP 서버는 받은 요청에 대해 ACK를 보내서 요청을 마무리 한다

</details>

<details><summary> 공인 IP주소와 사설IP 주소 매핑하는 방법(작동 방식) </summary>
  
외부에서 온 통신에서 목적지 주소를 매핑 테이블을 확인하여 내부의 호스트의 주소로 NAT가 변경합니다.
내부에서 외부로의 통신의 경우도 출발지 주소를 NAT를 통해서 외부 주소로 변경하여 보냅니다.

외부에서 하나의 IP 주소에서 대해 내부에서 여러 IP 주소로 사용하는 경우, 포트 번호를 활용하여 포트 번호를 매핑 테이블에 포함하여 변환을 동시에 수행합니다. (NAPT)

학교 강의 자료인데, 이해에 도움이 될 것 같아 첨부합니다.

![NAT 작동](https://github.com/STUDY-0x0E/CS-STUDY/assets/66675919/85307038-241a-433d-a9a8-05af0290163a)

![NAPT](https://github.com/STUDY-0x0E/CS-STUDY/assets/66675919/b17890a0-a388-4c4a-9df2-705923dc228f)
</details>

<details><summary>IP란 무엇이고 역할에 대해서 설명</summary>

IP 프로토콜
- 지정한 IP 주소에 데이터 전달하기 위한 프로토콜
- 패킷 단위 통신

IP 주소    
네트워크 내에서 해당 호스트(노드)를 식별하는 유일한 주소  
  
  - MAC : 하드웨어를 식별할 수 있는 물리적인 식별자
  - Port : 프로세스의 식별자  

네트워크를 구분하기 위한 네트워크 식별자와 호스트를 구분하기 위한 호스트 식별자로 구성  
식별자를 통해 연결된 장치를 

</details>

<details><summary>IP 주소 체계에 대해서 설명</summary>

IPv4
- 32비트로 2^32개 사용 가능한 주소 체계
- 호스트가 속한 네트워크 부로 호스트의 주소인 호스트 부로 나뉜다

서브넷
- 라우터와 호스트를 연결하는 부분 네트워크

서브넷 마스크
- 서브넷 내의 IP를 결정 짓는 규칙
- xxx.xxx.xxx.xxx/x의 형식으로 표현되며 마지막 수를 통해 상위 비트를 결정한다
  - 숫자에 해당하는 상위 비트를 모두 1 나머지를 0으로 하면 AND 연산을 통해 네트워크 부와 호스트 부를 추출할 수 있다.

![image](https://github.com/STUDY-0x0E/CS-STUDY/assets/66675919/020bfc09-9406-4d64-be91-8e618855b43a)

![image](https://github.com/STUDY-0x0E/CS-STUDY/assets/66675919/2a4e0592-7206-4711-aec9-b5f17abe7f15)
</details>

<details><summary>네트워크 계층에서 IP 프로토콜을 사용하는 이유</summary>

데이터를 전송하면서 최종 목적지에 도착할 수 있도록 라우팅 해주는 것이 네트워크 계층입니다.  
이 과정에서 어느 목적지에 전송할지 논리적인 주소인 IP 주소를 통해 최적 경로를 라우팅할 수 있게 IP 프로토콜을 사용합니다.

</details>

<details><summary>HTTP1.1 과 HTTP2.0의 차이</summary>

HTTP 1.1은 keep alive를 통해서 한 번의 3-way handshake 이후로 반복적으로 발생하는 것을 막아 RTT를 감소시켰으나 네트워크 내의 같은 큐에 있는 패킷의 크기에 따라 다른 패킷이 지연(TCP는 순서 보장이 이뤄지므로)되는 HOL Blocking (Head Of Line Blocking)이 발생했습니다.  

HTTP 2.0은 이러한 문제를 해결하기 위해서 Multiplexed 기술을 도입하는데, 1개의 세션으로 여러 요청을 순서에 상관없이 여러 개의 Stream으로 받아 단일 연결 내에서도 동시에 여러 메시지를 받을 수 있게 했습니다.

</details>

<details><summary>패킷을 주고 받는 방식</summary>

패킷의 송수신처의 IP 주소와 MAC 주소가 결정되면 라우팅을 통해서 어떤 경로로 갈지 결정하게 됩니다.  
그 과정에서 각각의 라우터는 패킷을 받고, 자신의 위치에서 수신처로 보내기 위해 라우팅을 진행합니다.  

하지만 라우터는 모든 네트워크의 주소를 알지 못하기 때문에 다음 라우터 MAC 주소를 수신처로 정하고, IP를 최종 수신처로 설정하여 다음 라우터로 라우팅을 진행합니다. 이렇게 라우터에서 라우터를 거치면서 홉 바이 홉 통신을 통해서 패킷은 최종 IP 주소지에 도착하게 됩니다.  

</details>

<details><summary>HTTP2.0의 멀티플렉싱에 대해 설명</summary>

HTTP 2.0은 HTTP 1.x보다 지연 시간을 줄이고 응답 시간을 더 빠르게 하기 위해 멀티 플렉싱, 헤더 압축, 서버 푸시, 요청의 우선 순위와 같은 기능을 지원하는 프로토콜입니다.

멀티 플렉싱은 기존의 HTTP 1.x 방식에서 데이터당 한 번의 연결이 발생하여 나타나는 지연 시간을 해결하기 위한 방법으로 한 번의 요청에 대해 각 데이터를 각각의 병렬 스트림으로 송수신을 진행하여 특정 스트림에 대한 문제는 해당 스트림에 대해서만 영향을 미치도록 진행하여 빠르게 송수신을 할 수 있도록 하는 방법입니다.

</details>

<details><summary>흐름제어와 혼잡제어에 대해 설명</summary>

TCP 통신에서 패킷 손실, 순서 바뀜 등의 문제가 발생할 수 있는데, 이런 문제를 해결하기 위한 방법으로 흐름 제어와 혼잡 제어가 있습니다.

흐름 제어  
- 송신측과 수신측 사이의 데이터 처리 속도 차이를 해결하기 위한 방법
- 송신측의 전송량이 수신측의 처리량 보다 클 경우 수신측의 큐를 초과하여 패킷 손실이 발생할 수 있으므로 제어가 필요

1. Stop And Wait  
- 매번 전송한 패킷에 대해서 확인 응답을 받아야만 다음 패킷 전송을 진행하는 방식
- 피드백 손상과 중복 전송을 우려하여 순서번호를 활용한다
- 무조건 하나의 패킷에 대한 수신에 대해 ACK를 받아야 진행하므로 비효율적이고 지연 시간이 크다

2. Go-Back-N ARQ  
![image](https://github.com/STUDY-0x0E/CS-STUDY/assets/66675919/17d10eb9-4b3e-449f-b073-d90b4a2e0aeb)

- 동작 방식  
  - 송신 윈도우(2^m - 1 크기, m은 순서번호 필드 비트 수)만큼 송신을 진행하고, 수신측에서 ACK를 수신하면 해당 데이터를 송신 윈도우에서 제거하고 다음 데이터로 범위를 늘려 송신 진행(윈도우 이동)
  - 만약 수신자가 데이터를 순서대로 받지 못하거나, 수신 받지 못하여 ACK가 오지 않는다면 마지막 ACK 다음 데이터를 모두 폐기하고 재전송
  - 구현이 간단하나 불필요한 재전송이 발생할 수 있음  
- 세그먼트를 하나씩 수신하므로 수신 윈도우의 크기는 1이 됨

3. Selective Repeat  
![image](https://github.com/STUDY-0x0E/CS-STUDY/assets/66675919/46838995-354c-4a7e-a703-461cc1acf96d)
- 동작 방식
  - 누적 ACK(누적되는 순서 번호가 맞는 ACK)가 수신되면 송신 윈도우를 ACK만큼 이동
  - 비누적 ACK(누적되는 순서 번호가 맞지 않는 ACK)가 수신되면 해당 세크먼트의 수신 사실 기록
  - 세그먼트 재전송 타이머가 종료될 때까지 ACK가 수신되지 않으면 해당 세그먼트 재전송(오류가 발생한 세그먼트에 대해서만 전송함) 
  - 수신자는 누적 정상 세그먼트를 수신하면 수신 윈도우를 이동하고, 비누적 정상 세그먼트를 수신하면 ACK를 회신하고 해당 세그먼트는 버퍼에 유지
- 비교적 성능이 좋으나, 구현이 어려움

혼잡 제어
- 트래픽 증가로 인해 발생하는 큐잉 지연 및 오버 플로우를 낮추는 방법
- 네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송 속도를 강제로 줄이는 방법

1. Slow Start  
송신 윈도우 크기를 1로 시작하며 패킷이 문제없이 도착하면 각각의 패킷마다 송신 윈도우의 크기를 1씩 증가시킨다.  
결과적으로 한 번의 전송 주기가 끝나면 송신 윈도우의 크기가 2배씩 증가한다 => 지수적 증가  
타임 아웃 발생 시, 임계치를 윈도우의 절반으로 설정한다  
윈도우가 인계치에 도달하면 혼잡 회피에 진입한다

2. Congestion Avoidance (혼잡 회피)  
윈도우가 임계치에 도달하면 RTT마다 윈도우의 크기를 1씩 증가 시켜 선형적으로 증가시킨다

3. Fast Retransmit (빠른 재전송)  
수신측에서 도착해야할 순서 번호의 패킷이 도착하지 않고 다음 패킷이 도착한 경우 ACK 패킷을 제대로 도착한 패킷의 다음 순서 번호를 ACK에 담아 보낸다.  
중복된 순번의 ACK가 3번 도착하게 되면 송신측에서는 경미한 혼잡이 발생한 것으로 판단하고, 재전송을 진행하고 윈도우의 크기를 감소시킨다.

4. Fast Recovery (빠른 회복)  
혼잡이 발생한 경우 임계치의 크기를 현재 윈도우의 1/2로 설정한다.  
손실된 세그먼트를 재전송하고, 임계치의 크기를 3 늘린다.
여전히 중복 ACK가 수신될 경우 윈도우의 크기를 1씩 늘린다.
정상 ACK가 수신될 경우 현재 윈도우의 크기를 임계치로 설정하고, 혼잡 회피에 진입한다.

![image](https://github.com/STUDY-0x0E/CS-STUDY/assets/66675919/06e8d0bc-5fa4-4331-9046-790b321308a2)

</details>

<br>



> 차우열

<details><summary>OSI 7계층에 대해서 간략하게 설명</summary>
  
OSI 7계층은 물리계층, 데이터 링크 계층, 전송 계층, 세션 계층, 표현 계층, 응용 계층으로 구성되어 있습니다.


물리 계층은 0과 1로 이루어진 데이터를 전기신호로 변환하여 전송합니다.

데이터 링크 계층은 물리적 주소인 MAC주소를 이용하여 LAN내부에 존재하는 주변장치와 통신합니다. ethernet 등의 point to point protocol을 사용합니다.

네트워크 계층은 논리적 주소인 IP주소를 이용해 다른 LAN에 속한 장치와 통신합니다. 포워딩과 라우팅을 담당합니다.

전송 계층은 송신자와 수신자, 양 끝단의 사용자들이 통신할 수 있게합니다. TCP, UDP 등의 프로토콜이 잘 알려져 있습니다.

세션계층은 응용 프로세스간에 세션을 구축, 관리, 종료시키는 계층입니다.

표현 계층은 데이터를 변환하는 계층입니다. 송신 시스템에서 데이터 암호화, 수신 시스템에서는 데이터 복호화가 일어납니다.

응용 계층은 유저와 가장 가까운 층으로 일반적인 응용프로그램을 포함합니다.</details>

<details><summary>전송 계층에서 사용되는 프로토콜</summary>
  
전송 계층에서 사용되는 잘 알려진 프로토콜에는 TCP, UDP가 있습니다.

TCP는 연결 지향 방식으로 흐름제어 및 혼잡 제어를 통해 높은 신뢰성 및 전송 순서를 보장하지만, UDP보다 속도가 느립니다.

UDP는 비연결형 서비스로 CheckSum을 통한 최소한의 오류만 검출하여 TCP보다 빠르지만, 신뢰성이 낮고 전송 순서가 보장되지 않습니다.</details>

<details><summary>네트워크 계층에서 쓰이는 단위(PDU)</summary>
  
PDU는 계층마다 형태 및 명칭이 다릅니다. 
  
TCP/IP 5계층을 기준으로 물리계층에서는 비트, 데이터 링크 계층에서는 프레임, 인터넷 계층에서는 패킷, 전송 계층에서 TCP는 세그먼트, UDP는 데이터 그램, 응용 계층에서는 메세지 또는 데이터로 불립니다.
</details>

<details><summary>TCP 3-way-handshake 과정</summary>
  
3-way-handshake는 TCP/IP 프로토콜을 이용하는 응용프로그램에서 정확한 전송을 보장하기 위해 세션을 수립하는 과정으로 3단계로 진행됩니다.

첫번째 단계에서 클라이언트가 서버에 SYN 패킷을 전송합니다. 클라이언트는 서버의 응답을 대기하는 SYN_SENT상태가 됩니다.

두번째 단계에서 SYN요청을 받은 서버는 요청을 수락한다는 ACK와 SYN을 클라이언트에게 전송하고 서버는 SYN_RECEIVED상태가 됩니다. 

세번째 단계에서 서버의 응답인 ACK와 SYN을 받은 클라이언트는 서버로 ACK을 전송하고 연결이 성립됩니다.</details>

<details><summary>3way-handshake 장점 </summary>
  
3way-handshake는 클라이언트와 서버가 SYN에 무작위 값인 ISN을 보내고, ACK에 ISN+1을 서로에게 전송합니다.
  
  이 과정을 통해 서로 보낸 요청에 따라 적절한 응답을 할 수 있는지 확인되었을때 연결을 결정하여 신뢰성을 확보합니다.</details>

<details><summary> 로드밸런싱에 대해서 설명 </summary>
  
로드밸런싱은 클라이언트의 요청을 일관성 있게 응답하기 위해 여러대의 서버에 트래픽을 분배하는 방법입니다.

L4 로드밸런서는 전송계층에서 IP주소, MAP주소, 프로토콜로 트래픽을 분배할 수 있습니다.

L7 로드밸런서는 응용계층에서 HTTP 헤더, 쿠키 등과 같은 사용자의 요청을 기준으로 트래픽을 분배할 수 있습니다.</details>

<details><summary> 4-way-handshake 는 어느 경우에 사용되는지 </summary>
  
4-way-handshake는 TCP/IP 환경에서 서버와 클라이언트의 연결을 해제하는데 필요한 프로세스입니다.
</details>

<details><summary> 어떤 방식으로 진행되는지 설명 </summary>
  
첫번째 단계에서 클라이언트가 연결을 종료하겟다는 FIN flag를 서버로 전송합니다. 클라이언트는 FIN_WAIT1상태가 됩니다.

두번째 단계에서 FIN 요청을 받은 서버는 클라이언트로 응답인 ACK를 전송합니다.  서버는 CLOSE_WAIT상태가 되고, 응답을 받은 클라이언트는 FIN_WAIT2상태가 됩니다.

세번째 단계에서 연결을 종료할 준비가 된 서버는 클라이언트로 FIN flag를 전송합니다. 서버는 LAST_ACK상태가 됩니다.

네번째 단계에서 FIN flag를 받은 클라이언트는 TIME_WAIT 상태가 되며 ACK를 전송합니다. 서버가 ACK를 받으면 연결이 종료됩니다.</details>

<details><summary> Close wait, Time wait 왜 진행되는지 </summary>
  
Close wait는 클라이언트의 FIN요청을 받은 서버가 요청받은 프로세스를 완료하기까지 기다리는 상태입니다.
이 상태는 서버가 요청을 처리하고 정상적으로 연결을 종료하기 위해서 진행됩니다.
이 때, FIN wait2인 클라이언트는 서버의 교착상태등의 이유로 FIN요청을 받지 못하더라도 일정시간 이후 Time wait상태가 됩니다.

Time wait는 서버의 FIN요청을 받은 클라이언트가 연결세션을 유지하는 시간입니다.
세션을 종료한 후 종료하는 패킷이 있다면 그 패킷에 대한 데이터가 유실될 수 있는데, 이를 방지하기 위해 일정시간동안 연결을 유지하면서 잉여패킷을 기다립니다.
</details>

<br>




> 박지영

<details><summary> 쿠키란 무엇인가요? </summary>
  <br>
  쿠키는 서버가 사용자의 웹 브라우저에 전송하는 데이터 조각으로, key=value형식의 문자열 데이터 묶음입니다.<br>
  HTTP 프로토콜은 Stateless하기 때문에 서버와 클라이언트 간의 연결 유지를 구현하기 위해 서로를 인식할 수 있는 식별 데이터인 쿠키를 사용합니다.
</details>

<details><summary> 쿠키는 어디에 사용되나요? </summary>
  <br>
  쿠키는 세션 관리, 개인화, 트래킹에 사용됩니다. <br>
  로그인이나 장바구니 유지, 다크모드 혹은 언어 설정, 사용자의 데이터 수집을 통해 리타게팅 광고 등의 사례가 있습니다.
</details>

<details><summary> 쿠키와 세션의 차이점은 무엇인가요? </summary>
  <br>
  쿠키는 클라이언트의 웹 브라우저에 저장되고 세션은 서버에 있는 세션 저장소에 저장됩니다.
</details>

<details><summary> 언제 세션 대신 쿠키를 사용하나요? </summary>
  <br>
  세션은 서버의 자원을 사용하기 때문에 서버의 메모리와 속도 측면에서 쿠키가 유리한 경우가 있습니다.
</details>

<details><summary> HTTP 프로토콜이 Stateless한 것이 보완해야 될 약점인가요? </summary>
  <br>
  stateless하다는 것은 서버가 클라이언트의 상태를 저장하지 않는 것을 뜻합니다.<br>
  서버에 상태를 저장하지 않으므로 서버 확장이 용이하다는 장점이 있으나 클라이언트가 연결을 위한 데이터를 추가 전송해야한다는 단점이 있습니다.<br>
  그렇기 때문에 쿠키, 세션 등을 이용하여 최소한으로 상태를 유지할 수 있도록 해야 합니다.
</details>

<details><summary> TCP와 UDP 차이는 무엇인가요? </summary>
  <br>
  TCP는 신뢰성이 높고 전송 속도가 상대적으로 느리며 헤더 크기가 상대적으로 큽니다.<br>
  UDP는 데이터 손실이나 순서 뒤바뀜의 가능성이 있고 전송 속도가 빠르며 헤더 크기가 작습니다.
</details>

<details><summary> TCP와 UDP는 어떤 경우에 사용되나요? </summary>
  <br>
  TCP는 이메일 전송, 파일 전송과 같은 신뢰성 높은 연결을 위해 사용하고, UDP는 스트리밍, DNS와 같은 빠른 속도가 필요한 연결을 위해 사용합니다.
</details>

<details><summary> UDP는 신뢰성이 없는 건가요? </summary>
  <br>
  UDP는 각 패킷이 독립적으로 최적의 경로를 선택하여 이동하는 데이터그램 패킷 교환 방식을 사용하기 때문에 도착 순서가 달라지거나 데이터가 손실될 가능성이 있습니다.
</details>

<br>


> 박진아

<details><summary> HTTP1.0 에 대해서 설명 </summary>

- 단일 연결: 하나의 연결당 하나의 요청을 처리하도록 설계되어 있어 매 연결마다 3-way-handshake를 열기 때문에 RTT시간이 걸린다.

- 비연결성: 요청을 주고받을 때만 연결을 유지하고 응답을 주고나면 TCP/IP 연결을 끊는다.
  
</details>

<details><summary> HTTP 메소드에서 GET과 POST차이 </summary>

- GET은 URL 파리멑에 요청하는 데이터를 담아 보낸다. POST는 body에 데이터를 담아 보낸다. 

- GET요청은 멱등(연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질)하다.

- RESTFUL 관점에서 GET은 서버의 리소스에서 데이터를 요청할 때, POST는 리소스를 새로 생성하거나 업데이트 할 떄 사용한다.
</details>

<details><summary> HTTP의 다른 메소드  </summary>

  - PUT: 리소스를 변경한다.

  - DELETE: 특정 리소스를 삭제한다.

  - PATCH: 리소스의 일부분을 수정한다.
</details>

<details><summary> JWT에 대한 설명 </summary>
  
  인증과 인과 정보, 헤드(헤시 알고리즘) 페이로드(사용자 정보) 시그니처(헤더와 페이로드를 암호화 할 수 있는 공개키)로 구성되어 있다. 
  JSON은 일반적인 프로그래밍 언어이므로 범용성이 좋아 다른 플랫폼과의 통신 이점을 가진다.
</details>

<details><summary> 쿠키, 세션과 JWT 방식의 차이 </summary>

- 쿠키: 서버가 보낸 정보를 브라우저(클라이언트)에 저장한다.

- 세션: 서버는 사용자의 정보를 저장하고 session id를 쿠키에 저장한다.

- jwt: 인증 정보를 저장소를 따로 관리하지 않아도 사용자의 인증이 가능하다.
</details>

<details><summary> 어느 경우에 사용하면 되는지 설명 </summary>

- 쿠키: 사용자의 로그인 상태 유지 

- 세션: 특정 게시물에 접근하거나 특정 기능을 사용 (예: 은행 세션 로그인)

- JWT: 서로 다른 서비스 간에 사용자 정보를 안전하게 전달 할 때 사용 (예: OAuth)
</details>

<details><summary> 어플리케이션 계층에서 사용되는 프로토콜 </summary>

- HTTP, HTTPS, FTP, SMTP, DNS, DHCP

  - HTTP: 웹 브라우저와 웹 서버 간에 데이터를 전송
  
  - HTTPPS: HTTP의 보안 버전. SSL/TLS를 사용하여 데이터를 암호화
  
  - FTP: 파일 전송 프로토콜
  
  - SMTP: 전자 메일 프로토콜
  
  - DNS: 도메인 이름과 IP 주소를 매핑
  
  - DHCP: 네트워크에서 자동으로 IP 주소를 할당
</details>

<br>



> 남혜미

<details><summary> 주소창에 구글을 입력했을 때 발생하는 과정 </summary>
  
  (DNS (도메인) 와 HTTP 중 하나에 포커싱을 맞춰서 대답)
</details>

<details><summary> DNS의 역할 </summary>
  Domain name 과 IP주소를 매핑해준다.
</details>

<details><summary> TCP/IP 4계층에 대해서 설명 </summary>
  응용 계층, 전송 계층, 인터넷 계층, 링크 계층
</details>

<details><summary> HTTP와 HTTPS의 차이 </summary>
  
  HTTP의 보안 문제를 해결하기 위해 TSL/SSL을 적용하여 데이터를 암호화한게 HTTPS이다.
</details>

<details><summary> 프로토콜에 대해 설명 </summary>
  서로 다른 기기에서 데이터(메시지)를 원할하게 주고 받기 위한 통신 규약 및 약속이다.
</details>


